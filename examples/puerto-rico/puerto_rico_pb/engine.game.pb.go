// Generated by protoc-gen-game. DO NOT EDIT.
package puerto_rico_pb

import (
	"context"
	"fmt"
	"github.com/angelbeltran/game-engine/protoc-gen-game/game_engine_pb"
	"google.golang.org/grpc"
	"net"
	"sync"
)

func NewServer(port uint) (*grpc.Server, net.Listener, error) {
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
	if err != nil {
		return nil, nil, err
	}

	srv := grpc.NewServer()
	RegisterActionsServer(srv, new(gameEngine))

	return srv, lis, nil
}

type gameEngine struct {
	UnimplementedActionsServer
}

func (e *gameEngine) SetPlayers(ctx context.Context, in *Count) (*Response, error) {
	state.Lock()
	defer state.Unlock()

	// Enforce the rules
	allowed := true == true

	if !allowed {
		return &Response{
			Error: &game_engine_pb.Error{
				Code: "826de622-ad54-4b65-3395-bb4d3828e67b",
				Msg:  "dummy error",
			},
		}, nil
	}

	// Apply any effects

	if state.Players == nil {
		state.Players = &State_Players{}
	}

	if state.Players.Player_1 == nil {
		state.Players.Player_1 = &Player{}
	}

	state.Players.Player_1.Present = true

	state.Quarries = in.Count

	// Construct the response
	res := Response{
		State: new(State),
	}

	res.State.Started = state.Started

	if res.State.Players == nil {
		res.State.Players = &State_Players{}
	}

	if res.State.Players.Player_1 == nil {
		res.State.Players.Player_1 = &Player{}
	}

	res.State.Players.Player_1.Present = state.Players.Player_1.Present

	if res.State.Players == nil {
		res.State.Players = &State_Players{}
	}

	if res.State.Players.Player_2 == nil {
		res.State.Players.Player_2 = &Player{}
	}

	res.State.Players.Player_2.Present = state.Players.Player_2.Present

	if res.State.Players == nil {
		res.State.Players = &State_Players{}
	}

	if res.State.Players.Player_3 == nil {
		res.State.Players.Player_3 = &Player{}
	}

	res.State.Players.Player_3.Buildings = state.Players.Player_3.Buildings

	return &res, nil
}

func (e *gameEngine) Start(ctx context.Context, in *EmptyMsg) (*Response, error) {
	state.Lock()
	defer state.Unlock()

	// Enforce the rules
	allowed := (state.Started == false) && (state.Players != nil && state.Players.Player_1 != nil && state.Players.Player_1.Present == true) && (state.Players != nil && state.Players.Player_2 != nil && state.Players.Player_2.Present == true) && (state.Players != nil && state.Players.Player_3 != nil && state.Players.Player_3.Present == true) && ((state.Players != nil && state.Players.Player_4 != nil && state.Players.Player_4.Present == true) || (state.Players != nil && state.Players.Player_5 != nil && state.Players.Player_5.Present == false))

	if !allowed {
		return &Response{
			Error: &game_engine_pb.Error{
				Code: "57e0c77b-3e2b-431c-c5ed-ee81a89d5ee6",
				Msg:  "game has already started",
			},
		}, nil
	}

	// Apply any effects

	state.Started = true

	// Construct the response
	res := Response{
		State: new(State),
	}

	return &res, nil
}

func (e *gameEngine) Accept(ctx context.Context, in *RoleChoice) (*Response, error) {
	return &Response{
		Error: &game_engine_pb.Error{
			Msg: "unimplemented",
		},
	}, nil
}

func (e *gameEngine) Purchase(ctx context.Context, in *BuildingChoice) (*Response, error) {
	return &Response{
		Error: &game_engine_pb.Error{
			Msg: "unimplemented",
		},
	}, nil
}

func (e *gameEngine) Load(ctx context.Context, in *GoodToShip) (*Response, error) {
	return &Response{
		Error: &game_engine_pb.Error{
			Msg: "unimplemented",
		},
	}, nil
}

func (e *gameEngine) Craft(ctx context.Context, in *EmptyMsg) (*Response, error) {
	return &Response{
		Error: &game_engine_pb.Error{
			Msg: "unimplemented",
		},
	}, nil
}

func (e *gameEngine) CraftExtra(ctx context.Context, in *GoodChoice) (*Response, error) {
	return &Response{
		Error: &game_engine_pb.Error{
			Msg: "unimplemented",
		},
	}, nil
}

func (e *gameEngine) WelcomeColonist(ctx context.Context, in *EmptyMsg) (*Response, error) {
	return &Response{
		Error: &game_engine_pb.Error{
			Msg: "unimplemented",
		},
	}, nil
}

func (e *gameEngine) WelcomeColonistFromSupply(ctx context.Context, in *EmptyMsg) (*Response, error) {
	return &Response{
		Error: &game_engine_pb.Error{
			Msg: "unimplemented",
		},
	}, nil
}

func (e *gameEngine) ApplyColonistToBuilding(ctx context.Context, in *BuildingChoice) (*Response, error) {
	return &Response{
		Error: &game_engine_pb.Error{
			Msg: "unimplemented",
		},
	}, nil
}

func (e *gameEngine) ApplyColonistToPlantation(ctx context.Context, in *PlantationChoice) (*Response, error) {
	return &Response{
		Error: &game_engine_pb.Error{
			Msg: "unimplemented",
		},
	}, nil
}

func (e *gameEngine) ApplyColonistToQuarry(ctx context.Context, in *EmptyMsg) (*Response, error) {
	return &Response{
		Error: &game_engine_pb.Error{
			Msg: "unimplemented",
		},
	}, nil
}

func (e *gameEngine) RefillColonistShip(ctx context.Context, in *EmptyMsg) (*Response, error) {
	return &Response{
		Error: &game_engine_pb.Error{
			Msg: "unimplemented",
		},
	}, nil
}

func (e *gameEngine) Settle(ctx context.Context, in *PlantationChoice) (*Response, error) {
	return &Response{
		Error: &game_engine_pb.Error{
			Msg: "unimplemented",
		},
	}, nil
}

func (e *gameEngine) ConstructQuarry(ctx context.Context, in *EmptyMsg) (*Response, error) {
	return &Response{
		Error: &game_engine_pb.Error{
			Msg: "unimplemented",
		},
	}, nil
}

func (e *gameEngine) Trade(ctx context.Context, in *GoodChoice) (*Response, error) {
	return &Response{
		Error: &game_engine_pb.Error{
			Msg: "unimplemented",
		},
	}, nil
}

func (e *gameEngine) EndAction(ctx context.Context, in *PlayerChoice) (*Response, error) {
	return &Response{
		Error: &game_engine_pb.Error{
			Msg: "unimplemented",
		},
	}, nil
}

var state struct {
	State
	sync.Mutex
}
