syntax = "proto3";
package puerto_rico_game;

import "google/protobuf/descriptor.proto";
import "github.com/angelbeltran/game-engine/protoc-gen-game/game_engine.proto";
import "github.com/angelbeltran/game-engine/examples/puerto-rico/role.proto";
import "github.com/angelbeltran/game-engine/examples/puerto-rico/building.proto";
import "github.com/angelbeltran/game-engine/examples/puerto-rico/good.proto";
import "github.com/angelbeltran/game-engine/examples/puerto-rico/player.proto";
import "github.com/angelbeltran/game-engine/examples/puerto-rico/plantation.proto";
import "github.com/angelbeltran/game-engine/examples/puerto-rico/cargo_ship.proto";
import "github.com/angelbeltran/game-engine/examples/puerto-rico/state.proto";

option go_package = "github.com/angelbeltran/game-engine/examples/puerto-rico/puerto_rico_pb";

service Actions {
  option (game_engine.is_action_service) = true;

  // Game start

  // TODO: test enums

  /*
  rpc SetPlayers(Count) returns (Response) {
    option (game_engine.action).effect = {
      update: {
        dest: { path: [ 'players', 'player_1', 'present' ] }
        src: { value: { bool: true } }

        // key describes the type of value being set. The path at dest is
        // verified to have this type
        bool: {
          // could be constant value.
          constant: true

          // could be reference to the rpc input or state.
          // can only define one of these.
          input: [ 'some', 'input', 'property' ]
          // state: [ 'player1', 'is', 'the', 'best' ]

          // could be the result of a function. the field name indicates the
          // function's signature. here, there is a single argument, a bool.
          bool_func: {
            name: NOT

            // precisely one of the following must be specified.

            // 'input' indicates a property of the rpc method's input that houls
            // should be used as the argument of the function.
            input: [ 'some', 'property', 'of', 'the', 'input' ]

            // 'state' indicates the same as 'input', but for the state.
            state: [ 'some', 'property', 'of', 'the', 'state' ]

            // another function's output could be used as the input here! this
            // allows for functional composition and arbitrarily complex and
            // useful functions to be constructed. the field name indicates the
            // function's signature. here, the argument is binary function
            // requiring two values, two strings. look at the 'int_int_func'
            // example below for an explanation of binrary functions.
            string_string_func: {
              name: EQ

              state1: [
                'some',
                'string',
                'property',
                'of',
                'interest',
              ]
              constant: 'some value to compare against'
            }
          }

          // this function requires two integer arguments
          int_int_func: {
            name: GTE

            // exactly one of 'input1' or 'state1' must be provided, or a
            // function whose output type matches.
            state1: [ 'player_1', 'cash' ]
            // input1: [ 'player_1', 'cash' ]
            // string_func: { name: LEN state: [ 'player_1', 'name' ] }

            // exactly one of 'input2', 'state2', or 'constant' must be
            // provided. 'constant' can be used to curry binary functions into
            // custom unary functions.
            constant: 450
          }

          // 'if' allows the value to depend on a predicate,
          // (input, state) -> {true, false}.
          //
          // the if block inherits the output type of the context the block is
          // placed in. here, the 'if' block must output a 'bool'
          if: {
            // predicate is an object that resolves to a bool. in fact it should
            // be the same kind being described so far. obviously, these
            // structures can be very deeply nested!
            predicate: {}

            // then is an object that resolves to the 'it's output type, in
            // this example, a bool. 'if' resolves to this value if predicate
            // resolves to true.
            then: {}

            // else is like 'then', but is resolved to if predicate resolves to
            // false.
            else: {}
          }
        }
      }
    };

    option (game_engine.action).effect = {
      update: {
        dest: { path: [ 'quarries' ] }
        src: { input: { path: [ 'count' ] } }
      }
    };

    option (game_engine.action).rule = {
      single: {
        left: { value: { bool: true } }
        operator: EQ
        right: { value: { bool: true } }
      }
    };

    option (game_engine.action).response = {
      path: [ 'started' ]
    };
    option (game_engine.action).response = {
      path: [ 'players', 'player_1', 'present' ]
    };
    option (game_engine.action).response = {
      path: [ 'players', 'player_2', 'present' ]
    };
    option (game_engine.action).response = {
      path: [ 'players', 'player_3', 'buildings' ]
    };

    option (game_engine.action).error = {
      code: "826de622-ad54-4b65-3395-bb4d3828e67b"
      msg: "dummy error"
    };
  };
  */

  rpc SetPlayers(Count) returns (Response) {
    option (game_engine.action).rule = {
      bool_bool_func: {
        name: AND
        bool_func_1: {
          name: NOT
          state: { path: [ 'started' ] }
        }
        int_int_func_2: {
          name: LTE
          constant_1: 3
          input_2: { path: [ 'count' ] }
        }
      }
    };

    option (game_engine.action).effect = {
      update: {
        state: { path: [ 'players', 'player_1', 'present' ] }
        value: {
          bool: {
            int_int_func: {
              name: LTE
              constant_1: 3
              input_2: { path: [ 'count' ] }
            }
          }
        }
      }
    };

    option (game_engine.action).effect = {
      update: {
        state: { path: [ 'players', 'player_2', 'present' ] }
        value: {
          bool: {
            int_int_func: {
              name: LTE
              constant_1: 3
              input_2: { path: [ 'count' ] }
            }
          }
        }
      }
    };

    option (game_engine.action).effect = {
      update: {
        state: { path: [ 'players', 'player_3', 'present' ] }
        value: {
          bool: {
            int_int_func: {
              name: LTE
              constant_1: 3
              input_2: { path: [ 'count' ] }
            }
          }
        }
      }
    };

    option (game_engine.action).effect = {
      update: {
        state: { path: [ 'players', 'player_4', 'present' ] }
        value: {
          bool: {
            int_int_func: {
              name: LTE
              constant_1: 4
              input_2: { path: [ 'count' ] }
            }
          }
        }
      }
    };

    option (game_engine.action).effect = {
      update: {
        state: { path: [ 'players', 'player_5', 'present' ] }
        value: {
          bool: {
            int_int_func: {
              name: LTE
              constant_1: 5
              input_2: { path: [ 'count' ] }
            }
          }
        }
      }
    };

    option (game_engine.action).response = {
      path: [ 'started' ]
    };
    option (game_engine.action).response = {
      path: [ 'players', 'player_1', 'present' ]
    };
    option (game_engine.action).response = {
      path: [ 'players', 'player_2', 'present' ]
    };
    option (game_engine.action).response = {
      path: [ 'players', 'player_3', 'present' ]
    };
    option (game_engine.action).response = {
      path: [ 'players', 'player_4', 'present' ]
    };
    option (game_engine.action).response = {
      path: [ 'players', 'player_5', 'present' ]
    };

    option (game_engine.action).error = {
      code: "826de622-ad54-4b65-3395-bb4d3828e67b"
      msg: "dummy error"
    };
  };

  rpc Start(EmptyMsg) returns (Response) {
    option (game_engine.action).effect = {
      update: {
        state: { path: [ 'started' ] }
        value: { bool: { constant: true } }
      }
    };

    option (game_engine.action).rule = {
      bool_bool_func: {
        name: AND
        bool_func_1: {
          name: NOT
          state: { path: [ 'started' ] }
        }
        bool_bool_func_2: {
          name: AND
          state_1: { path: [ 'players', 'player_1', 'present' ] }
          bool_bool_func_2: {
            name: AND
            state_1: { path: [ 'players', 'player_2', 'present' ] }
            bool_bool_func_2: {
              name: AND
              state_1: { path: [ 'players', 'player_3', 'present' ] }
              bool_bool_func_2: {
                name: OR
                state_1: { path: [ 'players', 'player_4', 'present' ] }
                bool_func_2: {
                  name: NOT
                  state: { path: [ 'players', 'player_5', 'present' ] }
                }
              }
            }
          }
        }
      }
    };

    /*
    option (game_engine.action).rule = {
      and: {
        rules: [
          {
            single: {
              left: { prop: { path: [ 'started' ] } }
              operator: EQ
              right: { value: { bool: false } }
            }
          },
          {
            single: {
              left: { prop: { path: [ 'players', 'player_1', 'present' ] } }
              operator: EQ
              right: { value: { bool: true } }
            }
          },
          {
            single: {
              left: { prop: { path: [ 'players', 'player_2', 'present' ] } }
              operator: EQ
              right: { value: { bool: true } }
            }
          },
          {
            single: {
              left: { prop: { path: [ 'players', 'player_3', 'present' ] } }
              operator: EQ
              right: { value: { bool: true } }
            }
          },
          {
            or: {
              rules: [
                {
                  single: {
                    left: {
                      prop: { path: [ 'players', 'player_4', 'present' ] }
                    }
                    operator: EQ
                    right: { value: { bool: true } }
                  }
                },
                {
                  single: {
                    left: {
                      prop: { path: [ 'players', 'player_5', 'present' ] }
                    }
                    operator: EQ
                    right: { value: { bool: false } }
                  }
                }
              ]
            }
          }
        ]
      }
    };
    */

    option (game_engine.action).error = {
      code: "57e0c77b-3e2b-431c-c5ed-ee81a89d5ee6"
      msg: "game has already started"
    };
  };

  // General gameplay

  rpc Accept(RoleChoice) returns (Response);

  // Action: Builder
  rpc Purchase(BuildingChoice) returns (Response);

  // Action: Captain
  rpc Load(GoodToShip) returns (Response);

  // Action: Craftsman
  rpc Craft(EmptyMsg) returns (Response);
  rpc CraftExtra(GoodChoice) returns (Response);

  // Action: Mayor
  rpc WelcomeColonist(EmptyMsg) returns (Response);
  rpc WelcomeColonistFromSupply(EmptyMsg) returns (Response);
  rpc ApplyColonistToBuilding(BuildingChoice) returns (Response);
  rpc ApplyColonistToPlantation(PlantationChoice) returns (Response);
  rpc ApplyColonistToQuarry(EmptyMsg) returns (Response);
  rpc RefillColonistShip(EmptyMsg) returns (Response);

  // Action: Settler
  rpc Settle(PlantationChoice) returns (Response);
  rpc ConstructQuarry(EmptyMsg) returns (Response);

  // Action: Trademan
  rpc Trade(GoodChoice) returns (Response);

  rpc EndAction(PlayerChoice) returns (Response);
}

message Response {
  option (game_engine.is_action_service_response) = true;

  State state = 1;
  game_engine.Error error = 2;
}

// Action messages

message EmptyMsg {}

message Count {
  uint32 count = 1;
}

message RoleChoice {
  RoleID role = 1;
}

message BuildingChoice {
  Building building = 1;
}

message GoodToShip {
  GoodID good = 1;
  CargoShipID ship = 2;
}

message GoodChoice {
  GoodID good = 1;
}

message PlantationChoice {
  PlantationID plantation = 1;
}

message PlayerChoice {
  PlayerID player = 1;
}
