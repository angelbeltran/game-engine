// Generated by protoc-gen-game/generation. DO NOT EDIT.
package template

{{- $types := .Types }}
{{- $typesToGoTypes := .TypesToGoTypes }}

const serverTemplate = `{{`// Generated by protoc-gen-game. DO NOT EDIT.
package {{ .Package }}


{{- $package := .Package }}
{{- $state := .State }}
{{- $responseType := .Response.GetName }}
{{- $responseStateField := .ResponseStateField }}
{{- $responseErrorField := .ResponseErrorField }}
{{- $stateVariable := .StateVariable }}
{{- $inputVariable := .InputVariable }}


import (
{{ range $_, $import := .Imports }}	{{ printf "%q" $import }}
	"github.com/angelbeltran/game-engine/protoc-gen-game/generate/go_func"
{{ end }}
)


//
// Server and state initialization
//

func NewServer(port uint) (*grpc.Server, net.Listener, error) {
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
	if err != nil {
		return nil, nil, err
	}

	srv := grpc.NewServer()
	Register{{ .Service.GetName }}Server(srv, new(gameEngine))

	return srv, lis, nil
}

type gameEngine struct {
	Unimplemented{{ .Service.GetName }}Server
}

var state = newGameState()

func newGameState() gameState {
	s := gameState{
		{{ $state.GetName }}: new({{ $state.GetName }}),
		Mutex: new(sync.Mutex),
	}

	{{ template "initialize" NewMessageInitializerParams (printf "s.%s" $state.GetName) $package $state }}

	return s
}

func (s *{{ $state.GetName }}) Copy() *{{ $state.GetName }} {
	c := new({{ $state.GetName }})
	*c = *s

	{{ template "copy" NewMessageCopyParams "c" "s" $package $state }}

	return c
}

type gameState struct {
	*{{ $state.GetName }}
	*sync.Mutex
}

func newResponse() {{ $responseType }} {
	var res {{ $responseType }}

	{{ template "initialize" NewMessageInitializerParams "res" $package .Response }}

	return res
}


//
// Service methods
//

{{- range $_, $bundle := .Methods }}
func (e *gameEngine) {{ $bundle.Method.GetName }}(ctx context.Context, in *{{ $bundle.Method.GetInputType.GetName }}) (*{{ $responseType }}, error) {
	{{- with $action := $bundle.Action -}}
		state.Lock()
		defer state.Unlock()

		// Enforce the rules

		allowed, err := {{ template "BoolValue" NewBoolValueParams $action.Rule $inputVariable $stateVariable }}.Value()
		if err != nil {
			return &{{ $responseType }}{
				{{ $responseErrorField }}: &game_engine_pb.Error{
					Msg: fmt.Sprint(err),
				},
			}, nil
		}
		if !allowed {
			return &{{ $responseType }}{
				{{ $responseErrorField }}: &game_engine_pb.Error{
					Code: {{ printf "%q" $action.Error.Code }},
					Msg: {{ printf "%q" $action.Error.Msg }},
				},
			}, nil
		}

		// Apply any effects

		next := {{ $stateVariable }}.{{ $state.GetName }}.Copy()

		{{- range $effect := $action.Effect }}

		{{- if $effect.GetUpdate }}
		{{ template "Reference" NewReferenceParams "next" $effect.GetUpdate.State }}, err ={{" "}}
		{{- template "Value" NewValueParams $effect.GetUpdate.Value $inputVariable $stateVariable }}.Value()
		if err != nil {
			return &{{ $responseType }}{
				{{ $responseErrorField }}: &game_engine_pb.Error{
					Msg: fmt.Sprintf("failed to apply effects: %v", err),
				},
			}, nil
		}

		{{- else }}
			{{ failUndefinedEffect }}
		{{- end }}
		{{- end }}

		state.{{ $state.GetName }} = next

		// Construct the response
		res := newResponse()

		{{- range $ref := $action.Response }}
			{{ template "Reference" NewReferenceParams (printf "res.%s" $responseStateField ) $ref }} = {{ template "Reference" NewReferenceParams "next" $ref }}
		{{- end }}

		return &res, nil

	{{- else }}

		return &{{ $responseType }}{
			{{ $responseErrorField }}: &game_engine_pb.Error{
				Msg: "unimplemented",
			},
		}, nil

	{{- end }}
}
{{ end }}


{{- /* Message Initializations */}}

{{- define "initialize" }}
{{/* Expects MessageInitializerParams */}}
	{{- $ident := .Identifier }}
	{{- $package := .Package }}

	{{- range $field := .MessageDescriptor.GetFields }}
		{{- if or $field.GetMessageType $field.IsMap }}
			{{- $typeName := (goTypeOfField $field).String }}

			{{- $isPointer := eq (index $typeName 0) '*' }}
			{{- if $isPointer }}
				{{- $typeName = slice $typeName 1 }}
			{{- end }}

			{{- $parts := split $typeName "." }}
			{{- $n := len $parts }}
			{{- if or (eq $n 0) (gt $n 2 )}}
				{{- errBadTypeName $typeName }}
			{{- else if eq $n 2 }}
				{{- /*$typeName = index $parts 1 */}}

				{{- if eq (index $parts 0) $package }}
					{{- /* Target package. Trim package name. */}}
					{{- $typeName = index $parts 1 }}
				{{- else }}
				{{- end }}
			{{- end }}

			{{- if $field.GetMessageType }}
				{{- $lh := printf "%s.%s"  $ident (camelCase $field.GetName) }}

				{{- if $isPointer }}
		{{- $lh }} = new({{ $typeName }})
				{{- end }}

				{{- template "initialize" NewMessageInitializerParams $lh $package $field.GetMessageType }}

			{{- else }}
				{{- $lh := printf "%s.%s"  $ident (camelCase $field.GetName) }}

				{{- if $isPointer }}
		{{- $lh }} = make({{ $typeName }})
				{{- end }}

			{{- end }}

		{{- end }}
	{{- end }}
{{- end }}


{{- /* Message Copying */}}

{{- define "copy" }}
{{/* Expects MessageCopyParams */}}
	{{- $lhIdent := .LeftHandIdentifier }}
	{{- $rhIdent := .RightHandIdentifier }}
	{{- $package := .Package }}

	{{- range $field := .MessageDescriptor.GetFields }}
		{{- if or $field.GetMessageType $field.IsMap }}
			{{- $typeName := (goTypeOfField $field).String }}

			{{- $isPointer := eq (index $typeName 0) '*' }}
			{{- if $isPointer }}
				{{- $typeName = slice $typeName 1 }}
			{{- end }}

			{{- $parts := split $typeName "." }}
			{{- $n := len $parts }}
			{{- if or (eq $n 0) (gt $n 2 )}}
				{{- errBadTypeName $typeName }}
			{{- else if eq $n 2 }}
				{{- /*$typeName = index $parts 1 */}}

				{{- if eq (index $parts 0) $package }}
					{{- /* Target package. Trim package name. */}}
					{{- $typeName = index $parts 1 }}
				{{- else }}
				{{- end }}
			{{- end }}

			{{- if $field.GetMessageType }}
				{{- $lh := printf "%s.%s"  $lhIdent (camelCase $field.GetName) }}
				{{- $rh := printf "%s.%s"  $rhIdent (camelCase $field.GetName) }}

				{{- if $isPointer }}
		{{- $lh }} = new({{ $typeName }})
		*{{ $lh }} = *({{ $rh }})
				{{- end }}

				{{- template "copy" NewMessageCopyParams $lh $rh $package $field.GetMessageType }}

			{{- else }}
				{{- $lh := printf "%s.%s"  $lhIdent (camelCase $field.GetName) }}
				{{- $rh := printf "%s.%s"  $rhIdent (camelCase $field.GetName) }}

		{{- $lh }} = make({{ $typeName }})
		for k, v := range {{ $rh }} { {{ $lh }}[k] = v /* TODO: these need to be deep copies */}

			{{- end }}

		{{- end }}
	{{- end }}
{{- end }}

`}}


{{ `{{/* Expression Evaluations */}}` }}

{{`{{- define "Reference" }}
{{- /* Expects a ReferenceParams */}}
{{- .Variable }}{{ range $_, $field := .Reference.Path }}.{{ camelCase $field }}{{ end }}
{{- end }}`}}


{{- /* Value Templates */}}

{{`{{- define "Value" }}`}}
{{- /* Expects a ValueParams */}}
{{- range $i, $type := $types }}
{{- $type = capitalize $type }}
{{- $valueType := printf "%sValue" $type }}
{{- $getter := printf "Get%s" $type }}
{{ "{{-" }} {{ if $i }}else {{ end }}if .Value.{{ $getter }} {{ "}}{{" }} template "{{ $valueType }}" New{{ $valueType }}Params .Value.{{ $getter }} .InputVariable .StateVariable {{ "}}" }}
{{- end }}
{{ "{{- end }}" }}
{{`{{- end }}`}}

{{- range $_, $type := $types }}
{{- $type = capitalize $type }}
{{- $valueType := printf "%sValue" $type }}

{{ printf `{{- define "%s" }}` $valueType }}
{{ `{{-` }} /* Expects a {{ $valueType }}Params */{{ `}}` }}
{{ "{{-" }} if .Value.GetInput {{ "}}{{" }} template "Reference" NewReferenceParams .InputVariable .Value.GetInput {{ "}}" }}
{{ "{{-" }} else if .Value.GetState {{ "}}{{" }} template "Reference" NewReferenceParams .StateVariable .Value.GetState {{ "}}" }}

{{- /* Unary function output at input */}}
{{- range $_, $domain := $types }}
{{- $domain = capitalize $domain }}
{{- $getter := printf ".Value.Get%sFunc" $domain }}
{{ "{{-" }} else if {{ $getter }} {{ "}}{{" }} template "{{ $domain }}To{{ $type }}Function" New{{ $domain }}To{{ $type }}FunctionParams {{ $getter }} .InputVariable .StateVariable {{ "}}" }}
{{- end }}

{{- /* Binary function output at input */}}
{{- range $_, $domain1 := $types }}
{{- $domain1 = capitalize $domain1 }}
{{- range $_, $domain2 := $types }}
{{- $domain2 = capitalize $domain2 }}
{{ "{{-" }} else if .Value.Get{{ $domain1 }}{{ $domain2 }}Func {{ "}}{{" }} template "{{ $domain1 }}And{{ $domain2 }}To{{ $type }}Function" New{{ $domain1 }}And{{ $domain2 }}To{{ $type }}FunctionParams .Value.Get{{ $domain1 }}{{ $domain2 }}Func .InputVariable .StateVariable {{ "}}" }}
{{- end }}
{{- end }}

{{- /* N-ary function output at input */}}
{{- range $_, $domain := $types }}
{{- $domain = capitalize $domain }}
{{- $getter := printf ".Value.Get%ssFunc" $domain }}
{{ "{{-" }} else if {{ $getter }} {{ "}}{{" }} template "{{ $domain }}sTo{{ $type }}Function" New{{ $domain }}sTo{{ $type }}FunctionParams {{ $getter }} .InputVariable .StateVariable {{ "}}" }}
{{- end }}

{{ `{{-` }} else if .Value.GetIf {{ `}}{{` }} template "{{ $type }}ValueIf" New{{ $type }}ValueIfParams .Value.GetIf .InputVariable .StateVariable {{ `}}` }}
{{ "{{-" }} else {{ "}}" }}go_func.{{ $type }}({{"{{" }} printf "%v" .Value.GetConstant {{ "}})" }}
{{`{{- end }}`}}
{{`{{- end }}`}}

{{- end }}


{{ `{{- /* Unary Function Templates */}}` }}

{{ range $_, $domain := $types }}
{{- $domainGoType := index $typesToGoTypes $domain }}
{{- $domain = capitalize $domain }}
{{- range $_, $codomain := $types }}
{{- $codomain = capitalize $codomain }}
{{- $funcTypeName := printf "%sTo%sFunction" $domain $codomain }}
{{ `{{-` }} define "{{ $funcTypeName }}" {{ `-}}` }}
{{ `{{- /*`}} Expects a {{ $funcTypeName }}Params {{ `*/}}` }}
{{ `{{-` }} if not .Function.Name {{ `}}{{` }} failNoFunctionName "{{ $funcTypeName }}" {{ `}}{{` }} end {{ `}}` -}}
go_func.{{- $domain }}To{{ $codomain }}_{{ `{{- camelCase .Function.Name.String }}(` }}
	{{ `{{-` }} if .Function.GetInput {{ `}}` }}go_func.{{ $domain }}({{ $domainGoType }}({{ `{{` }} template "Reference" NewReferenceParams .InputVariable .Function.GetInput {{ `}}` }}))
	{{ `{{-` }} else if .Function.GetState {{ `}}` }}go_func.{{ $domain }}({{ $domainGoType }}({{ `{{` }} template "Reference" NewReferenceParams .StateVariable .Function.GetState {{ `}}` }}))

	{{- /* Unary function output at input */}}
	{{- range $fieldDomain := $types }}
	{{- $fieldDomain = capitalize $fieldDomain }}
	{{- $funcFieldName := printf "%sFunc" $fieldDomain }}
	{{- $nestedFuncTypeName := printf "%sTo%sFunction" $fieldDomain $domain }}
	{{- $getter := printf ".Function.Get%s" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}

	{{- /* Binary function output at input */}}
	{{- range $fieldDomain1 := $types }}
	{{- $fieldDomain1 = capitalize $fieldDomain1 }}
	{{- range $fieldDomain2 := $types }}
	{{- $fieldDomain2 = capitalize $fieldDomain2 }}
	{{- $funcFieldName := printf "%s%sFunc" $fieldDomain1 $fieldDomain2 }}
	{{- $nestedFuncTypeName := printf "%sAnd%sTo%sFunction" $fieldDomain1 $fieldDomain2 $domain }}
	{{- $getter := printf ".Function.Get%s" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}
	{{- end }}

	{{- /* N-ary function output at input */}}
	{{- range $fieldDomain := $types }}
	{{- $fieldDomain = capitalize $fieldDomain }}
	{{- $funcFieldName := printf "%ssFunc" $fieldDomain }}
	{{- $nestedFuncTypeName := printf "%ssTo%sFunction" $fieldDomain $domain }}
	{{- $getter := printf ".Function.Get%s" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}

	{{ `{{-` }} else if .If {{ `}}{{` }} template "{{ $domain }}ValueIf" New{{ $domain }}ValueIfParams .If .InputVariable .StateVariable {{ `}}` }}

	{{ `{{-` }} end {{ `}}` }})
{{ `{{-` }} end {{ `}}` }}
{{ end }}
{{- end }}


{{ `{{/* Binary Function Templates */}}` }}

{{ range $_, $domain1 := $types }}
{{- $domain1GoType := index $typesToGoTypes $domain1 }}
{{- $domain1 = capitalize $domain1 }}
{{- range $_, $domain2 := $types }}
{{- $domain2GoType := index $typesToGoTypes $domain2 }}
{{- $domain2 = capitalize $domain2 }}
{{- range $_, $codomain := $types }}
{{- $codomain = capitalize $codomain }}
{{- $funcTypeName := printf "%sAnd%sTo%sFunction" $domain1 $domain2 $codomain }}
{{ `{{-` }} define "{{ $funcTypeName }}" {{ `-}}` }}
{{ `{{- /*`}} Expects a {{ $funcTypeName }}Params {{ `*/}}` }}
{{ `{{-` }} if not .Function.Name {{ `}}{{` }} failNoFunctionName "{{ $funcTypeName }}" {{ `}}{{` }} end {{ `}}` -}}
go_func.{{- $domain1 }}And{{ $domain2 }}To{{ $codomain }}_{{ `{{- camelCase .Function.Name.String }}(` }}
	{{ `{{-` }} if .Function.GetInput_1 {{ `}}` }}go_func.{{ $domain1 }}({{ $domain1GoType }}({{`{{` }} template "Reference" NewReferenceParams .InputVariable .Function.GetInput_1 {{ `}}` }}))
	{{ `{{-` }} else if .Function.GetState_1 {{ `}}` }}go_func.{{ $domain1 }}({{ $domain1GoType }}({{ `{{` }} template "Reference" NewReferenceParams .StateVariable .Function.GetState_1 {{ `}}` }}))

	{{- /* Unary function output at input 1 */}}
	{{- range $fieldDomain := $types }}
	{{- $fieldDomain = capitalize $fieldDomain }}
	{{- $funcFieldName := printf "%sFunc" $fieldDomain }}
	{{- $nestedFuncTypeName := printf "%sTo%sFunction" $fieldDomain $domain1 }}
	{{- $getter := printf ".Function.Get%s_1" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}

	{{- /* Binary function output at input 1 */}}
	{{- range $fieldDomain1 := $types }}
	{{- $fieldDomain1 = capitalize $fieldDomain1 }}
	{{- range $fieldDomain2 := $types }}
	{{- $fieldDomain2 = capitalize $fieldDomain2 }}
	{{- $funcFieldName := printf "%s%sFunc" $fieldDomain1 $fieldDomain2 }}
	{{- $nestedFuncTypeName := printf "%sAnd%sTo%sFunction" $fieldDomain1 $fieldDomain2 $domain1 }}
	{{- $getter := printf ".Function.Get%s_1" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}
	{{- end }}

	{{- /* N-ary function output at input 1 */}}
	{{- range $fieldDomain := $types }}
	{{- $fieldDomain = capitalize $fieldDomain }}
	{{- $funcFieldName := printf "%ssFunc" $fieldDomain }}
	{{- $nestedFuncTypeName := printf "%ssTo%sFunction" $fieldDomain $domain1 }}
	{{- $getter := printf ".Function.Get%s_1" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}

	{{ `{{-` }} else if .Function.GetIf_1 {{ `}}{{` }} template "{{ $domain1 }}ValueIf" New{{ $domain1 }}ValueIfParams .Function.GetIf_1 .InputVariable .StateVariable {{ `}}` }}

	{{ `{{-` }} else {{ `}}` }}go_func.{{ $domain1 }}({{`{{` }} printf "%v" .Function.GetConstant_1 {{ `}}` }})

	{{ `{{-` }} end {{ `}}` }},

	{{ `{{-` }} if .Function.GetInput_2 {{ `}}` }}go_func.{{ $domain2 }}({{ $domain2GoType }}({{ `{{` }} template "Reference" NewReferenceParams .InputVariable .Function.GetInput_2 {{ `}}` }}))
	{{ `{{-` }} else if .Function.GetState_2 {{ `}}` }}go_func.{{ $domain2 }}({{ $domain2GoType }}({{ `{{` }} template "Reference" NewReferenceParams .StateVariable .Function.GetState_2 {{ `}}` }}))

	{{- /* Unary function output at input 2 */}}
	{{- range $fieldDomain := $types }}
	{{- $fieldDomain = capitalize $fieldDomain }}
	{{- $funcFieldName := printf "%sFunc" $fieldDomain }}
	{{- $nestedFuncTypeName := printf "%sTo%sFunction" $fieldDomain $domain2 }}
	{{- $getter := printf ".Function.Get%s_2" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}

	{{- /* Binary function output at input 2 */}}
	{{- range $fieldDomain1 := $types }}
	{{- $fieldDomain1 = capitalize $fieldDomain1 }}
	{{- range $fieldDomain2 := $types }}
	{{- $fieldDomain2 = capitalize $fieldDomain2 }}
	{{- $funcFieldName := printf "%s%sFunc" $fieldDomain1 $fieldDomain2 }}
	{{- $nestedFuncTypeName := printf "%sAnd%sTo%sFunction" $fieldDomain1 $fieldDomain2 $domain2 }}
	{{- $getter := printf ".Function.Get%s_2" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}
	{{- end }}

	{{- /* N-ary function output at input 2 */}}
	{{- range $fieldDomain := $types }}
	{{- $fieldDomain = capitalize $fieldDomain }}
	{{- $funcFieldName := printf "%ssFunc" $fieldDomain }}
	{{- $nestedFuncTypeName := printf "%ssTo%sFunction" $fieldDomain $domain2 }}
	{{- $getter := printf ".Function.Get%s_2" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}

	{{ `{{-` }} else if .Function.GetIf_2 {{ `}}{{` }} template "{{ $domain2 }}ValueIf" New{{ $domain2 }}ValueIfParams .Function.GetIf_2 .InputVariable .StateVariable {{ `}}` }}

	{{ `{{-` }} end {{ `}}` }})
{{ `{{-` }} end {{ `}}` }}
{{ end }}
{{ end }}
{{- end }}


{{ `{{- /* N-ary Function Templates */}}` }}

{{ range $_, $domain := $types }}
{{- $domainGoType := index $typesToGoTypes $domain }}
{{- $domain = capitalize $domain }}
{{- range $_, $codomain := $types }}
{{- $codomain = capitalize $codomain }}
{{- $funcTypeName := printf "%ssTo%sFunction" $domain $codomain }}
{{ `{{-` }} define "{{ $funcTypeName }}" {{ `-}}` }}
{{ `{{- /*`}} Expects a {{ $funcTypeName }}Params {{ `*/}}` }}
{{ `{{-` }} if not .Function.Name {{ `}}{{` }} failNoFunctionName "{{ $funcTypeName }}" {{ `}}{{` }} end {{ `}}` -}}
go_func.{{ $domain }}sTo{{ $codomain }}_{{ `{{- camelCase .Function.Name.String }}(` }}
{{ `{{-` }} $inputVariable := .InputVariable {{ `}}` }}
{{ `{{-` }} $stateVariable := .StateVariable {{ `}}` }}
{{ `{{-` }} range $arg := .Function.Arguments {{ `}}` }}

	{{ `{{-` }} if $arg.GetInput {{ `}}` }}go_func.{{ $domain }}({{ $domainGoType }}({{ `{{` }} template "Reference" NewReferenceParams $inputVariable $arg.GetInput {{ `}}` }}))
	{{ `{{-` }} else if $arg.GetState {{ `}}` }}go_func.{{ $domain }}({{ $domainGoType }}({{ `{{` }} template "Reference" NewReferenceParams $stateVariable $arg.GetState {{ `}}` }}))

	{{- /* Unary function output at input */}}
	{{- range $fieldDomain := $types }}
	{{- $fieldDomain = capitalize $fieldDomain }}
	{{- $funcFieldName := printf "%sFunc" $fieldDomain }}
	{{- $nestedFuncTypeName := printf "%sTo%sFunction" $fieldDomain $domain }}
	{{- $getter := printf "$arg.Get%s" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} $inputVariable $stateVariable {{ `}}` }}
	{{- end }}

	{{- /* Binary function output at input */}}
	{{- range $fieldDomain1 := $types }}
	{{- $fieldDomain1 = capitalize $fieldDomain1 }}
	{{- range $fieldDomain2 := $types }}
	{{- $fieldDomain2 = capitalize $fieldDomain2 }}
	{{- $funcFieldName := printf "%s%sFunc" $fieldDomain1 $fieldDomain2 }}
	{{- $nestedFuncTypeName := printf "%sAnd%sTo%sFunction" $fieldDomain1 $fieldDomain2 $domain }}
	{{- $getter := printf "$arg.Get%s" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} $inputVariable $stateVariable {{ `}}` }}
	{{- end }}
	{{- end }}

	{{- /* N-ary function output at input */}}
	{{- range $fieldDomain := $types }}
	{{- $fieldDomain = capitalize $fieldDomain }}
	{{- $funcFieldName := printf "%ssFunc" $fieldDomain }}
	{{- $nestedFuncTypeName := printf "%ssTo%sFunction" $fieldDomain $domain }}
	{{- $getter := printf "$arg.Get%s" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} $inputVariable $stateVariable {{ `}}` }}
	{{- end }}

	{{ `{{-` }} else if $arg.GetIf {{ `}}{{` }} template "{{ $domain }}ValueIf" New{{ $domain }}ValueIfParams $arg.GetIf $inputVariable $stateVariable {{ `}}` }}

	{{ `{{-` }} else {{ `}}` }}go_func.{{ $domain }}({{`{{` }} printf "%v" $arg.GetConstant {{ `}}` }})

	{{ `{{-` }} end {{ `}}` }},
{{ `{{-` }} end {{ `}}` }})
{{ `{{-` }} end {{ `}}` }}
{{ end }}
{{- end }}


{{- /* If-Else control structures */}}

{{- range $type := $types }}
{{- $type = capitalize $type }}
{{ `{{-` }} define "{{ $type }}ValueIf" {{ `-}}` }}
{{ `{{- /* Expects a ` }}{{ $type }}{{`ValueIfParams */}}` -}}
func() go_func.{{ $type }} {
	if {{ `{{` }} template "BoolValue" NewBoolValueParams .If.Predicate .InputVariable .StateVariable {{ `}}` }} {
		return {{ `{{` }} template "{{ $type }}Value" New{{ $type }}ValueParams .If.Then .InputVariable .StateVariable {{ `}}` }}
	}

	return {{ `{{` }} template "{{ $type }}Value" New{{ $type }}ValueParams .If.Else .InputVariable .StateVariable {{ `}}` }}
}()
{{ `{{-` }} end {{ `}}` }}
{{ end }}

//
// Enum Key Mappings
//

{{`
{{- range $msgType, $enumType := .EnumToFieldMappings }}

{{- $fieldType := "" }}
{{- range $value := $enumType.GetValues }}
{{- with $num := $value.GetNumber }}
{{- $fieldType = ($msgType.FindFieldByNumber $num).GetMessageType.GetName }}
{{- end }}
{{- end }}

{{- $msgTypeName := goTypeForMessageWithoutTargetPackageName $msgType }}

func {{ goTypeForMessageWithCamelCasePackage $msgType }}FieldBy{{ $enumType.GetName }}(msg *{{ $msgTypeName }}, key {{ $enumType.GetName }}) (*{{ $fieldType }}, error) {
	switch key {
{{- range $value := $enumType.GetValues }}
{{- if $value.GetNumber }}
	case {{ $enumType.GetName }}_{{ $value.GetName }}:
		return msg.{{ camelCase ($msgType.FindFieldByNumber $value.GetNumber).GetName }}, nil
{{- end }}
{{- end }}
	}

	return nil, fmt.Errorf("unexpected {{ $enumType.GetName }} value: %v", key)
}
{{- end }}
`}}
`
