// Generated by protoc-gen-game/generation. DO NOT EDIT.
package template

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"strings"
	"text/template"

	"github.com/jhump/protoreflect/desc"
	"github.com/jhump/goprotoc/plugins"

	pb "github.com/angelbeltran/game-engine/protoc-gen-game/game_engine_pb"
)

{{- $types := .Types }}
{{- $typesToGoTypes := .TypesToGoTypes }}

//
// ----- Entrypoint -----
//

func GenerateService(w io.Writer, opts TemplateParams) error {

	// Parse template.

	tmpl, err := template.New("main").Funcs(template.FuncMap{
		"camelCase": (&plugins.GoNames{}).CamelCase,
		"goTypeOfField": names.GoTypeOfField,
		"goTypeForMessage": names.GoTypeForMessage,
		"goTypeForMessageWithoutTargetPackageName": func(md *desc.MessageDescriptor) string {
			s := names.GoTypeForMessage(md).String()
			parts := strings.Split(s, ".")

			if len(parts) == 0 {
				return s
			}
			if parts[0] == opts.Package {
				return parts[1]
			}

			return s
		},
		"goTypeForMessageWithCamelCasePackage": func(md *desc.MessageDescriptor) string {
			var name string

			for _, part := range strings.Split(names.GoTypeForMessage(md).String(), ".") {
				name += names.CamelCase(part)
			}

			return name
		},
		"failNoFunctionName": failNoFunctionName,
		"failUndefinedEffect": failUndefinedEffect,
		"split": strings.Split,
		"errBadTypeName": func(typeName string) (interface{}, error) {
			return nil, fmt.Errorf("type name has more that one '.': %s", typeName)
		},
		"NewEffectParams": NewEffectParams,
		"NewMessageInitializerParams": NewMessageInitializerParams,
		"NewReferenceParams": NewReferenceParams,
		"NewValueParams": NewValueParams,
		{{- range $_, $type := $types }}
		{{- $ident := printf "New%sValueParams" (capitalize $type) }}
		"{{ $ident }}": {{ $ident }},
		{{- end }}
		{{- range $_, $domain := $types }}
		{{- range $_, $codomain := $types }}
		{{- $ident := printf "New%sTo%sFunctionParams" (capitalize $domain) (capitalize $codomain) }}
		"{{ $ident }}": {{ $ident }},
		{{- end }}
		{{- end }}
		{{- range $_, $domain1 := $types }}
		{{- range $_, $domain2 := $types }}
		{{- range $_, $codomain := $types }}
		{{- $ident := printf "New%sAnd%sTo%sFunctionParams" (capitalize $domain1) (capitalize $domain2) (capitalize $codomain) }}
		"{{ $ident }}": {{ $ident }},
		{{- end }}
		{{- end }}
		{{- end }}
		{{- range $_, $domain := $types }}
		{{- range $_, $codomain := $types }}
		{{- $ident := printf "New%ssTo%sFunctionParams" (capitalize $domain) (capitalize $codomain) }}
		"{{ $ident }}": {{ $ident }},
		{{- end }}
		{{- end }}
		{{- range $type := $types }}
		{{- $ifType := printf "%sValueIf" (capitalize $type) }}
		{{- $ident := printf "New%sParams" $ifType }}
		"{{ $ident }}": {{ $ident }},
		{{- end }}
	}).Parse(Template)
	if err != nil {
		return fmt.Errorf("failed to parse service template: %w", err)
	}

	// Apply runtime parameters.

	out := bytes.NewBuffer([]byte{})

	if err := tmpl.Execute(out, opts); err != nil {
		return fmt.Errorf("failed to execute service template: %w", err)
	}

	// Format and write to file.

	b, err := ioutil.ReadAll(out)
	if err != nil {
		return fmt.Errorf("failed to read unformated templates: %w", err)
	}

	b, err = format.Source(b)
	if err != nil {
		return fmt.Errorf("failed to format generated templates: %w", err)
	}

	if _, err := w.Write(b); err != nil {
		return fmt.Errorf("failed to write out formatted templates: %w", err)
	}

	return nil
}

// TemplateParams hold all the arguments needed for the main template.
type TemplateParams struct {
	Package             string
	Imports             []string
	Service             *desc.ServiceDescriptor
	Methods             []MethodInfo
	State               *desc.MessageDescriptor
	Response            *desc.MessageDescriptor
	StateVariable       string
	InputVariable       string
	EnumToFieldMappings map[*desc.MessageDescriptor]*desc.EnumDescriptor
	ResponseStateField  string
	ResponseErrorField  string
}

// MethodInfo is a method and action pair.
type MethodInfo struct {
	Method *desc.MethodDescriptor
	Action *pb.Action
}

var names plugins.GoNames

const Template = `{{`// Generated by protoc-gen-game. DO NOT EDIT.
package {{ .Package }}

import (
{{ range $_, $import := .Imports }}	{{ printf "%q" $import }}
	"github.com/angelbeltran/game-engine/protoc-gen-game/proto-generation/go_func"
{{ end }}
)

func NewServer(port uint) (*grpc.Server, net.Listener, error) {
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
	if err != nil {
		return nil, nil, err
	}

	srv := grpc.NewServer()
	Register{{ .Service.GetName }}Server(srv, new(gameEngine))

	return srv, lis, nil
}

type gameEngine struct {
	Unimplemented{{ .Service.GetName }}Server
}

{{- $state := .State }}
{{- $responseType := .Response.GetName }}
{{- $responseStateField := .ResponseStateField }}
{{- $responseErrorField := .ResponseErrorField }}
{{- $stateVariable := .StateVariable }}
{{- $inputVariable := .InputVariable }}
{{- range $_, $bundle := .Methods }}
func (e *gameEngine) {{ $bundle.Method.GetName }}(ctx context.Context, in *{{ $bundle.Method.GetInputType.GetName }}) (*{{ $responseType }}, error) {
	{{- with $action := $bundle.Action -}}
		state.Lock()
		defer state.Unlock()

		// Enforce the rules

		allowed := {{ template "BoolValue" NewBoolValueParams $action.Rule $inputVariable $stateVariable }}
		if !allowed {
			return &{{ $responseType }}{
				{{ $responseErrorField }}: &game_engine_pb.Error{
					Code: {{ printf "%q" $action.Error.Code }},
					Msg: {{ printf "%q" $action.Error.Msg }},
				},
			}, nil
		}

		// Apply any effects

		{{- range $effect := $action.Effect }}
			{{ template "effect" NewEffectParams $effect $inputVariable $stateVariable }}
		{{- end }}

		// Construct the response
		res := NewResponse()

		{{- range $ref := $action.Response }}
			{{ template "Reference" NewReferenceParams (printf "res.%s" $responseStateField ) $ref }} = {{ template "Reference" NewReferenceParams $stateVariable $ref }}
		{{- end }}

		return &res, nil

	{{- else }}

		return &{{ $responseType }}{
			{{ $responseErrorField }}: &game_engine_pb.Error{
				Msg: "unimplemented",
			},
		}, nil

	{{- end }}
}
{{ end }}

var state = NewGameState()

type GameState struct {
	{{ .State.GetName }}
	sync.Mutex
}

func NewGameState() GameState {
	var s GameState
	
	{{ template "initialize" NewMessageInitializerParams (printf "s.%s" .State.GetName) .Package .State }}

	return s
}

func NewResponse() {{ $responseType }} {
	var res {{ $responseType }}

	{{ template "initialize" NewMessageInitializerParams "res" .Package .Response }}

	return res
}

{{- define "effect" }}
{{/* Expects EffectParams */}}
{{- if .Effect.GetUpdate }}
	{{- $up := .Effect.GetUpdate }}
	{{ template "Reference" NewReferenceParams .StateVariable $up.State }} = 
	{{- template "Value" NewValueParams $up.Value .InputVariable .StateVariable }}
{{- else }}
	{{ failUndefinedEffect }}
{{- end }}
{{- end }}

{{- define "initialize" }}
{{/* Expects MessageInitializerParams */}}
	{{- $ident := .Identifier }}
	{{- $package := .Package }}

	{{- range $field := .MessageDescriptor.GetFields }}
		{{- if or $field.GetMessageType $field.IsMap }}
			{{- $typeName := (goTypeOfField $field).String }}

			{{- $isPointer := eq (index $typeName 0) '*' }}
			{{- if $isPointer }}
				{{- $typeName = slice $typeName 1 }}
			{{- end }}

			{{- $parts := split $typeName "." }}
			{{- $n := len $parts }}
			{{- if or (eq $n 0) (gt $n 2 )}}
				{{- errBadTypeName $typeName }}
			{{- else if eq $n 2 }}
				{{- /*$typeName = index $parts 1 */}}

				{{- if eq (index $parts 0) $package }}
					{{- /* Target package. Trim package name. */}}
					{{- $typeName = index $parts 1 }}
				{{- else }}
				{{- end }}
			{{- end }}

			{{- if $field.GetMessageType }}
				{{- $lh := printf "%s.%s"  $ident (camelCase $field.GetName) }}

				{{- if $isPointer }}
		{{- $lh }} = new({{ $typeName }})
				{{- end }}

				{{- template "initialize" NewMessageInitializerParams $lh $package $field.GetMessageType }}

			{{- else }}
				{{- $lh := printf "%s.%s"  $ident (camelCase $field.GetName) }}

				{{- if $isPointer }}
		{{- $lh }} = make({{ $typeName }})
				{{- end }}

			{{- end }}

		{{- end }}
	{{- end }}
{{- end }}

`}}

{{ `{{/* Expression Evaluations */}}` }}

{{`{{- define "Reference" }}
{{- /* Expects a ReferenceParams */}}
{{- .Variable }}{{ range $_, $field := .Reference.Path }}.{{ camelCase $field }}{{ end }}
{{- end }}`}}

{{- /* Value Templates */}}

{{`{{- define "Value" }}`}}
{{- /* Expects a ValueParams */}}
{{- range $i, $type := $types }}
{{- $type = capitalize $type }}
{{- $valueType := printf "%sValue" $type }}
{{- $getter := printf "Get%s" $type }}
{{ "{{-" }} {{ if $i }}else {{ end }}if .Value.{{ $getter }} {{ "}}{{" }} template "{{ $valueType }}" New{{ $valueType }}Params .Value.{{ $getter }} .InputVariable .StateVariable {{ "}}" }}
{{- end }}
{{ "{{- end }}" }}
{{`{{- end }}`}}

{{- range $_, $type := $types }}
{{- $type = capitalize $type }}
{{- $valueType := printf "%sValue" $type }}

{{ printf `{{- define "%s" }}` $valueType }}
{{ `{{-` }} /* Expects a {{ $valueType }}Params */{{ `}}` }}
{{ "{{-" }} if .Value.GetInput {{ "}}{{" }} template "Reference" NewReferenceParams .InputVariable .Value.GetInput {{ "}}" }}
{{ "{{-" }} else if .Value.GetState {{ "}}{{" }} template "Reference" NewReferenceParams .StateVariable .Value.GetState {{ "}}" }}

{{- /* Unary function output at input */}}
{{- range $_, $domain := $types }}
{{- $domain = capitalize $domain }}
{{- $getter := printf ".Value.Get%sFunc" $domain }}
{{ "{{-" }} else if {{ $getter }} {{ "}}{{" }} template "{{ $domain }}To{{ $type }}Function" New{{ $domain }}To{{ $type }}FunctionParams {{ $getter }} .InputVariable .StateVariable {{ "}}" }}
{{- end }}

{{- /* Binary function output at input */}}
{{- range $_, $domain1 := $types }}
{{- $domain1 = capitalize $domain1 }}
{{- range $_, $domain2 := $types }}
{{- $domain2 = capitalize $domain2 }}
{{ "{{-" }} else if .Value.Get{{ $domain1 }}{{ $domain2 }}Func {{ "}}{{" }} template "{{ $domain1 }}And{{ $domain2 }}To{{ $type }}Function" New{{ $domain1 }}And{{ $domain2 }}To{{ $type }}FunctionParams .Value.Get{{ $domain1 }}{{ $domain2 }}Func .InputVariable .StateVariable {{ "}}" }}
{{- end }}
{{- end }}

{{- /* N-ary function output at input */}}
{{- range $_, $domain := $types }}
{{- $domain = capitalize $domain }}
{{- $getter := printf ".Value.Get%ssFunc" $domain }}
{{ "{{-" }} else if {{ $getter }} {{ "}}{{" }} template "{{ $domain }}sTo{{ $type }}Function" New{{ $domain }}sTo{{ $type }}FunctionParams {{ $getter }} .InputVariable .StateVariable {{ "}}" }}
{{- end }}

{{ `{{-` }} else if .Value.GetIf {{ `}}{{` }} template "{{ $type }}ValueIf" New{{ $type }}ValueIfParams .Value.GetIf .InputVariable .StateVariable {{ `}}` }}
{{ "{{-" }} else {{ "}}{{" }} printf "%v" .Value.GetConstant {{ "}}" }}
{{`{{- end }}`}}
{{`{{- end }}`}}

{{- end }}


{{ `{{- /* Unary Function Templates */}}` }}

{{ range $_, $domain := $types }}
{{- $domainGoType := index $typesToGoTypes $domain }}
{{- $domain = capitalize $domain }}
{{- range $_, $codomain := $types }}
{{- $codomain = capitalize $codomain }}
{{- $funcTypeName := printf "%sTo%sFunction" $domain $codomain }}
{{ `{{-` }} define "{{ $funcTypeName }}" {{ `-}}` }}
{{ `{{- /*`}} Expects a {{ $funcTypeName }}Params {{ `*/}}` }}
{{ `{{-` }} if not .Function.Name {{ `}}{{` }} failNoFunctionName "{{ $funcTypeName }}" {{ `}}{{` }} end {{ `}}` -}}
go_func.{{- $domain }}To{{ $codomain }}_{{ `{{- camelCase .Function.Name.String }}(` }}{{ $domainGoType }}(
	{{ `{{-` }} if .Function.GetInput {{ `}}{{` }} template "Reference" NewReferenceParams .InputVariable .Function.GetInput {{ `}}` }}
	{{ `{{-` }} else if .Function.GetState {{ `}}{{` }} template "Reference" NewReferenceParams .StateVariable .Function.GetState {{ `}}` }}

	{{- /* Unary function output at input */}}
	{{- range $fieldDomain := $types }}
	{{- $fieldDomain = capitalize $fieldDomain }}
	{{- $funcFieldName := printf "%sFunc" $fieldDomain }}
	{{- $nestedFuncTypeName := printf "%sTo%sFunction" $fieldDomain $domain }}
	{{- $getter := printf ".Function.Get%s" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}

	{{- /* Binary function output at input */}}
	{{- range $fieldDomain1 := $types }}
	{{- $fieldDomain1 = capitalize $fieldDomain1 }}
	{{- range $fieldDomain2 := $types }}
	{{- $fieldDomain2 = capitalize $fieldDomain2 }}
	{{- $funcFieldName := printf "%s%sFunc" $fieldDomain1 $fieldDomain2 }}
	{{- $nestedFuncTypeName := printf "%sAnd%sTo%sFunction" $fieldDomain1 $fieldDomain2 $domain }}
	{{- $getter := printf ".Function.Get%s" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}
	{{- end }}

	{{- /* N-ary function output at input */}}
	{{- range $fieldDomain := $types }}
	{{- $fieldDomain = capitalize $fieldDomain }}
	{{- $funcFieldName := printf "%ssFunc" $fieldDomain }}
	{{- $nestedFuncTypeName := printf "%ssTo%sFunction" $fieldDomain $domain }}
	{{- $getter := printf ".Function.Get%s" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}

	{{ `{{-` }} else if .If {{ `}}{{` }} template "{{ $domain }}ValueIf" New{{ $domain }}ValueIfParams .If .InputVariable .StateVariable {{ `}}` }}

	{{ `{{-` }} end {{ `}}` }},
{{ `))` }}
{{ `{{-` }} end {{ `}}` }}
{{ end }}
{{- end }}


{{ `{{/* Binary Function Templates */}}` }}

{{ range $_, $domain1 := $types }}
{{- $domain1GoType := index $typesToGoTypes $domain1 }}
{{- $domain1 = capitalize $domain1 }}
{{- range $_, $domain2 := $types }}
{{- $domain2GoType := index $typesToGoTypes $domain2 }}
{{- $domain2 = capitalize $domain2 }}
{{- range $_, $codomain := $types }}
{{- $codomain = capitalize $codomain }}
{{- $funcTypeName := printf "%sAnd%sTo%sFunction" $domain1 $domain2 $codomain }}
{{ `{{-` }} define "{{ $funcTypeName }}" {{ `-}}` }}
{{ `{{- /*`}} Expects a {{ $funcTypeName }}Params {{ `*/}}` }}
{{ `{{-` }} if not .Function.Name {{ `}}{{` }} failNoFunctionName "{{ $funcTypeName }}" {{ `}}{{` }} end {{ `}}` -}}
go_func.{{- $domain1 }}And{{ $domain2 }}To{{ $codomain }}_{{ `{{- camelCase .Function.Name.String }}(` }}{{ $domain1GoType }}(
	{{ `{{-` }} if .Function.GetInput_1 {{ `}}{{` }} template "Reference" NewReferenceParams .InputVariable .Function.GetInput_1 {{ `}}` }}
	{{ `{{-` }} else if .Function.GetState_1 {{ `}}{{` }} template "Reference" NewReferenceParams .StateVariable .Function.GetState_1 {{ `}}` }}

	{{- /* Unary function output at input 1 */}}
	{{- range $fieldDomain := $types }}
	{{- $fieldDomain = capitalize $fieldDomain }}
	{{- $funcFieldName := printf "%sFunc" $fieldDomain }}
	{{- $nestedFuncTypeName := printf "%sTo%sFunction" $fieldDomain $domain1 }}
	{{- $getter := printf ".Function.Get%s_1" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}

	{{- /* Binary function output at input 1 */}}
	{{- range $fieldDomain1 := $types }}
	{{- $fieldDomain1 = capitalize $fieldDomain1 }}
	{{- range $fieldDomain2 := $types }}
	{{- $fieldDomain2 = capitalize $fieldDomain2 }}
	{{- $funcFieldName := printf "%s%sFunc" $fieldDomain1 $fieldDomain2 }}
	{{- $nestedFuncTypeName := printf "%sAnd%sTo%sFunction" $fieldDomain1 $fieldDomain2 $domain1 }}
	{{- $getter := printf ".Function.Get%s_1" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}
	{{- end }}

	{{- /* N-ary function output at input 1 */}}
	{{- range $fieldDomain := $types }}
	{{- $fieldDomain = capitalize $fieldDomain }}
	{{- $funcFieldName := printf "%ssFunc" $fieldDomain }}
	{{- $nestedFuncTypeName := printf "%ssTo%sFunction" $fieldDomain $domain1 }}
	{{- $getter := printf ".Function.Get%s_1" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}

	{{ `{{-` }} else if .Function.GetIf_1 {{ `}}{{` }} template "{{ $domain1 }}ValueIf" New{{ $domain1 }}ValueIfParams .Function.GetIf_1 .InputVariable .StateVariable {{ `}}` }}

	{{ `{{-` }} else {{ `}}{{` }} printf "%v" .Function.GetConstant_1 {{ `}}` }}

	{{ `{{-` }} end {{ `}}` }}), {{ $domain2GoType }}(

	{{ `{{-` }} if .Function.GetInput_2 {{ `}}{{` }} template "Reference" NewReferenceParams .InputVariable .Function.GetInput_2 {{ `}}` }}
	{{ `{{-` }} else if .Function.GetState_2 {{ `}}{{` }} template "Reference" NewReferenceParams .StateVariable .Function.GetState_2 {{ `}}` }}

	{{- /* Unary function output at input 2 */}}
	{{- range $fieldDomain := $types }}
	{{- $fieldDomain = capitalize $fieldDomain }}
	{{- $funcFieldName := printf "%sFunc" $fieldDomain }}
	{{- $nestedFuncTypeName := printf "%sTo%sFunction" $fieldDomain $domain2 }}
	{{- $getter := printf ".Function.Get%s_2" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}

	{{- /* Binary function output at input 2 */}}
	{{- range $fieldDomain1 := $types }}
	{{- $fieldDomain1 = capitalize $fieldDomain1 }}
	{{- range $fieldDomain2 := $types }}
	{{- $fieldDomain2 = capitalize $fieldDomain2 }}
	{{- $funcFieldName := printf "%s%sFunc" $fieldDomain1 $fieldDomain2 }}
	{{- $nestedFuncTypeName := printf "%sAnd%sTo%sFunction" $fieldDomain1 $fieldDomain2 $domain2 }}
	{{- $getter := printf ".Function.Get%s_2" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}
	{{- end }}

	{{- /* N-ary function output at input 2 */}}
	{{- range $fieldDomain := $types }}
	{{- $fieldDomain = capitalize $fieldDomain }}
	{{- $funcFieldName := printf "%ssFunc" $fieldDomain }}
	{{- $nestedFuncTypeName := printf "%ssTo%sFunction" $fieldDomain $domain2 }}
	{{- $getter := printf ".Function.Get%s_2" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}

	{{ `{{-` }} else if .Function.GetIf_2 {{ `}}{{` }} template "{{ $domain2 }}ValueIf" New{{ $domain2 }}ValueIfParams .Function.GetIf_2 .InputVariable .StateVariable {{ `}}` }}

	{{ `{{-` }} end {{ `}}` }}),
{{ `)` }}
{{ `{{-` }} end {{ `}}` }}
{{ end }}
{{ end }}
{{- end }}


{{ `{{- /* N-ary Function Templates */}}` }}

{{ range $_, $domain := $types }}
{{- $domainGoType := index $typesToGoTypes $domain }}
{{- $domain = capitalize $domain }}
{{- range $_, $codomain := $types }}
{{- $codomain = capitalize $codomain }}
{{- $funcTypeName := printf "%ssTo%sFunction" $domain $codomain }}
{{ `{{-` }} define "{{ $funcTypeName }}" {{ `-}}` }}
{{ `{{- /*`}} Expects a {{ $funcTypeName }}Params {{ `*/}}` }}
{{ `{{-` }} if not .Function.Name {{ `}}{{` }} failNoFunctionName "{{ $funcTypeName }}" {{ `}}{{` }} end {{ `}}` -}}
go_func.{{ $domain }}sTo{{ $codomain }}_{{ `{{- camelCase .Function.Name.String }}(` }}
{{ `{{-` }} $inputVariable := .InputVariable {{ `}}` }}
{{ `{{-` }} $stateVariable := .StateVariable {{ `}}` }}
{{ `{{-` }} range $arg := .Function.Arguments {{ `}}` }}

{{- $domainGoType }}(
	{{ `{{-` }} if $arg.GetInput {{ `}}{{` }} template "Reference" NewReferenceParams $inputVariable $arg.GetInput {{ `}}` }}
	{{ `{{-` }} else if $arg.GetState {{ `}}{{` }} template "Reference" NewReferenceParams $stateVariable $arg.GetState {{ `}}` }}

	{{- /* Unary function output at input */}}
	{{- range $fieldDomain := $types }}
	{{- $fieldDomain = capitalize $fieldDomain }}
	{{- $funcFieldName := printf "%sFunc" $fieldDomain }}
	{{- $nestedFuncTypeName := printf "%sTo%sFunction" $fieldDomain $domain }}
	{{- $getter := printf "$arg.Get%s" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} $inputVariable $stateVariable {{ `}}` }}
	{{- end }}

	{{- /* Binary function output at input */}}
	{{- range $fieldDomain1 := $types }}
	{{- $fieldDomain1 = capitalize $fieldDomain1 }}
	{{- range $fieldDomain2 := $types }}
	{{- $fieldDomain2 = capitalize $fieldDomain2 }}
	{{- $funcFieldName := printf "%s%sFunc" $fieldDomain1 $fieldDomain2 }}
	{{- $nestedFuncTypeName := printf "%sAnd%sTo%sFunction" $fieldDomain1 $fieldDomain2 $domain }}
	{{- $getter := printf "$arg.Get%s" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} $inputVariable $stateVariable {{ `}}` }}
	{{- end }}
	{{- end }}

	{{- /* N-ary function output at input */}}
	{{- range $fieldDomain := $types }}
	{{- $fieldDomain = capitalize $fieldDomain }}
	{{- $funcFieldName := printf "%ssFunc" $fieldDomain }}
	{{- $nestedFuncTypeName := printf "%ssTo%sFunction" $fieldDomain $domain }}
	{{- $getter := printf "$arg.Get%s" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} $inputVariable $stateVariable {{ `}}` }}
	{{- end }}

	{{ `{{-` }} else if $arg.GetIf {{ `}}{{` }} template "{{ $domain }}ValueIf" New{{ $domain }}ValueIfParams $arg.GetIf $inputVariable $stateVariable {{ `}}` }}

	{{ `{{-` }} else {{ `}}{{` }} printf "%v" $arg.GetConstant {{ `}}` }}

	{{ `{{-` }} end {{ `}}` }},
{{ `),{{-` }} end {{ `}}` }}
{{ `)` }}
{{ `{{-` }} end {{ `}}` }}
{{ end }}
{{- end }}


{{- /* If-Else control structures */}}

{{- range $type := $types }}
{{- $lowerCaseType := $type }}
{{- $type = capitalize $type }}
{{ `{{-` }} define "{{ $type }}ValueIf" {{ `-}}` }}
{{ `{{- /* Expects a ` }}{{ $type }}{{`ValueIfParams */}}` -}}
func() {{ $lowerCaseType }} {
	if {{ `{{` }} template "BoolValue" NewBoolValueParams .If.Predicate .InputVariable .StateVariable {{ `}}` }} {
		return {{ `{{` }} template "{{ $type }}Value" New{{ $type }}ValueParams .If.Then .InputVariable .StateVariable {{ `}}` }}
	}

	return {{ `{{` }} template "{{ $type }}Value" New{{ $type }}ValueParams .If.Else .InputVariable .StateVariable {{ `}}` }}
}()
{{ `{{-` }} end {{ `}}` }}
{{ end }}

//
// Enum Key Mappings
//

{{`
{{- range $msgType, $enumType := .EnumToFieldMappings }}

{{- $fieldType := "" }}
{{- range $value := $enumType.GetValues }}
{{- with $num := $value.GetNumber }}
{{- $fieldType = ($msgType.FindFieldByNumber $num).GetMessageType.GetName }}
{{- end }}
{{- end }}

{{- $msgTypeName := goTypeForMessageWithoutTargetPackageName $msgType }}

func {{ goTypeForMessageWithCamelCasePackage $msgType }}FieldBy{{ $enumType.GetName }}(msg *{{ $msgTypeName }}, key {{ $enumType.GetName }}) (*{{ $fieldType }}, error) {
	switch key {
{{- range $value := $enumType.GetValues }}
{{- if $value.GetNumber }}
	case {{ $enumType.GetName }}_{{ $value.GetName }}:
		return msg.{{ camelCase ($msgType.FindFieldByNumber $value.GetNumber).GetName }}, nil
{{- end }}
{{- end }}
	}

	return nil, fmt.Errorf("unexpected {{ $enumType.GetName }} value: %v", key)
}
{{- end }}
`}}
`

//
// ----- Simple State Or Input References -----
//

type ReferenceParams struct {
	Reference *pb.Reference
	Variable string
}

func NewReferenceParams(variable string, reference *pb.Reference) ReferenceParams {
	return ReferenceParams{
		Variable: variable,
		Reference: reference,
	}
}

//
// ----- Values -----
//

type ValueParams struct {
	Value *pb.Value
	InputVariable string
	StateVariable string
}

func NewValueParams(value *pb.Value, input, state string) ValueParams {
	return ValueParams{
		Value: value,
		InputVariable: input,
		StateVariable: state,
	}
}
{{ range $_, $type := $types }}
{{- $type = capitalize $type }}
{{- $valueType := printf "%sValue" $type }}
type {{ $valueType }}Params struct {
	Value *pb.{{ $valueType }}
	InputVariable string
	StateVariable string
}

func New{{ $valueType }}Params(value *pb.{{ $valueType }}, input, state string) {{ $valueType }}Params {
	return {{ $valueType }}Params{
		Value: value,
		InputVariable: input,
		StateVariable: state,
	}
}
{{ end }}

//
// ----- Unary Functions -----
//

{{- range $_, $domain := $types }}
{{- $domain = capitalize $domain }}
{{- range $_, $codomain := $types }}
{{- $codomain = capitalize $codomain }}
{{- $funcType := printf "%sTo%sFunction" $domain $codomain }}

type {{ $funcType }}Params struct {
	Function *pb.{{ $funcType }}
	InputVariable string
	StateVariable string
}

func New{{ $funcType }}Params(function *pb.{{ $funcType }}, input, state string) {{ $funcType }}Params {
	return {{ $funcType }}Params{
		Function: function,
		InputVariable: input,
		StateVariable: state,
	}
}
{{- end }}
{{- end }}

//
// ----- Binary Functions -----
//

{{- range $_, $domain1 := $types }}
{{- $domain1 = capitalize $domain1 }}
{{- range $_, $domain2 := $types }}
{{- $domain2 = capitalize $domain2 }}
{{- range $_, $codomain := $types }}
{{- $codomain = capitalize $codomain }}
{{- $funcType := printf "%sAnd%sTo%sFunction" $domain1 $domain2 $codomain }}

type {{ $funcType }}Params struct {
	Function *pb.{{ $funcType }}
	InputVariable string
	StateVariable string
}

func New{{ $funcType }}Params(function *pb.{{ $funcType }}, input, state string) {{ $funcType }}Params {
	return {{ $funcType }}Params{
		Function: function,
		InputVariable: input,
		StateVariable: state,
	}
}
{{- end }}
{{- end }}
{{- end }}

//
// ----- N-ary Functions -----
//

{{- range $_, $domain := $types }}
{{- $domain = capitalize $domain }}
{{- range $_, $codomain := $types }}
{{- $codomain = capitalize $codomain }}
{{- $funcType := printf "%ssTo%sFunction" $domain $codomain }}

type {{ $funcType }}Params struct {
	Function *pb.{{ $funcType }}
	InputVariable string
	StateVariable string
}

func New{{ $funcType }}Params(function *pb.{{ $funcType }}, input, state string) {{ $funcType }}Params {
	return {{ $funcType }}Params{
		Function: function,
		InputVariable: input,
		StateVariable: state,
	}
}
{{- end }}
{{- end }}

//
// ----- If-Else Control Structures -----
//

{{- range $type := $types }}
{{- $ifType := printf "%sValueIf" (capitalize $type) }}

type {{ $ifType }}Params struct {
	If *pb.{{ $ifType }}
	InputVariable string
	StateVariable string
}

func New{{ $ifType }}Params(v *pb.{{ $ifType }}, input, state string) {{ $ifType }}Params {
	return {{ $ifType }}Params{
		If: v,
		InputVariable: input,
		StateVariable: state,
	}
}
{{- end }}

//
// ----- Others parameter constructors -----
//

type EffectParams struct {
	Effect *pb.Effect
	InputVariable string
	StateVariable string
}

func NewEffectParams(effect *pb.Effect, input, state string) EffectParams {
	return EffectParams {
		Effect: effect,
		InputVariable: input,
		StateVariable: state,
	}
}

type ResponseParams struct {
	Reference *pb.Reference
	InputVariable string
	StateVariable string
}

func NewResponseParams(reference *pb.Reference, input, state string) ResponseParams {
	return ResponseParams {
		Reference: reference,
		InputVariable: input,
		StateVariable: state,
	}
}

type MessageInitializerParams struct {
	Identifier string
	Package string
	MessageDescriptor *desc.MessageDescriptor
}

func NewMessageInitializerParams(ident, pkg string, msg *desc.MessageDescriptor) MessageInitializerParams {
	return MessageInitializerParams {
		Identifier: ident,
		Package: pkg,
		MessageDescriptor: msg,
	}
}

//
// ----- Error constructors -----
//

func failNoFunctionName(funcType string) (interface{}, error) {
	return nil, fmt.Errorf("function name missing for function type %s", funcType)
}

func failUndefinedEffect() (interface{}, error) {
	return nil, fmt.Errorf("undefined effect")
}
