package main

import (
	"fmt"
	"strings"
	"text/template"

	"github.com/jhump/goprotoc/plugins"
	"github.com/jhump/protoreflect/desc"

	pb "angelbeltran/game-engine/protoc-gen-game/protos/game_engine_pb"
)

type mainTemplateParameters struct {
	Package string
	Imports []string
	Service *desc.ServiceDescriptor
	Methods []methodBundle
	State   *desc.MessageDescriptor
}

var defaultMethodImports = []string{
	"context",
	"fmt",
	"net",
	"sync",
	"google.golang.org/grpc",
	"angelbeltran/game-engine/protoc-gen-game/protos/game_engine_pb",
}

var mainTemplate = template.Must(template.New("main").Funcs(template.FuncMap{
	"joinCamelCase": joinCamelCase,
	"printRule":     printRule,
	"printEffect":   printEffect,
	"printValue":    extractValue,
}).Parse(`
// Generated by protoc-gen-game. DO NOT EDIT.
package {{.Package}}

import (
{{range $_, $import := .Imports}}	{{printf "%q" $import}}
{{end}}
)

func NewServer(port uint) (*grpc.Server, net.Listener, error) {
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
	if err != nil {
		return nil, nil, err
	}

	srv := grpc.NewServer()
	Register{{.Service.GetName}}Server(srv, new(gameEngine))

	return srv, lis, nil
}

type gameEngine struct {
	Unimplemented{{.Service.GetName}}Server
}

{{$state := .State}}
{{range $_, $bundle := .Methods}}
func (e *gameEngine) {{$bundle.Method.GetName}}(ctx context.Context, in *{{$bundle.Method.GetInputType.GetName}}) (*game_engine_pb.Error, error) {
	{{with $action := $bundle.Action}}
		state.Lock()
		defer state.Unlock()

		allowed := {{printRule "state" $action.Rule}}
		if !allowed {
			return &game_engine_pb.Error{
				Code: {{printf "%q" $action.Error.Code}},
				Msg: {{printf "%q" $action.Error.Msg}},
			}, nil
		}

		{{printEffect "state" $state $action.Effect}}

		return &game_engine_pb.Error{}, nil

	{{else}}

		return &game_engine_pb.Error{
			Msg: "unimplemented",
		}, nil

	{{end}}
}
{{end}}

var state struct{
	{{.State.GetName}}
	sync.Mutex
}
`))

var goNames plugins.GoNames

func printRule(prefix string, rule *pb.Rule) (string, error) {
	if s := rule.GetSingle(); s != nil {
		var op string

		switch v := s.GetOperator(); v {
		case pb.SingleRule_EQ:
			op = "=="
		case pb.SingleRule_NEQ:
			op = "!="
		case pb.SingleRule_LT:
			op = "<"
		case pb.SingleRule_LTE:
			op = "<="
		case pb.SingleRule_GT:
			op = ">"
		case pb.SingleRule_GTE:
			op = ">="
		default:
			return "", fmt.Errorf("unexpected operator: %s", v)
		}

		lh, err := encodeOperandWithNilChecks(prefix, s.GetLeft())
		if err != nil {
			return "", err
		}

		rh, err := encodeOperandWithNilChecks(prefix, s.GetRight())
		if err != nil {
			return "", err
		}

		return fmt.Sprintf("%s %s %s", lh, op, rh), nil
	}

	if and := rule.GetAnd(); and != nil {
		printed := make([]string, len(and.Rules))

		for i, r := range and.Rules {
			str, err := printRule(prefix, r)
			if err != nil {
				return "", err
			}

			printed[i] = "(" + str + ")"
		}

		return strings.Join(printed, " && "), nil
	}

	if or := rule.GetOr(); or != nil {
		printed := make([]string, len(or.Rules))

		for i, r := range or.Rules {
			str, err := printRule(prefix, r)
			if err != nil {
				return "", err
			}

			printed[i] = "(" + str + ")"
		}

		return strings.Join(printed, " || "), nil
	}

	return "", fmt.Errorf("empty rule definition")
}

func encodeOperandWithNilChecks(prefix string, op *pb.SingleRule_Operand) (string, error) {
	if f := op.GetField(); f != nil {
		allButLast := f.Name[:len(f.Name)-1]

		nilChecks := make([]string, len(allButLast))
		for i := range allButLast {
			nilChecks[i] = fmt.Sprintf("%s.%s != nil", prefix, joinCamelCase(f.Name[:i+1]))
		}

		return strings.Join(append(nilChecks, fmt.Sprintf("%s.%s", prefix, joinCamelCase(f.Name))), " && "), nil
	}

	if v := op.GetValue(); v != nil {
		val, err := extractValue(v)
		if err != nil {
			return "", err
		}

		return fmt.Sprint(val), nil
	}

	return "", fmt.Errorf("undefined operand")
}

func joinCamelCase(a []string) string {
	b := make([]string, len(a))
	for i, s := range a {
		b[i] = goNames.CamelCase(s)
	}
	return strings.Join(b, ".")
}

func extractValue(msg *pb.Value) (interface{}, error) {
	switch v := msg.GetValue().(type) {
	case *pb.Value_BoolValue:
		return v.BoolValue, nil
	case *pb.Value_IntegerValue:
		return v.IntegerValue, nil
	case *pb.Value_FloatValue:
		return v.FloatValue, nil
	case *pb.Value_StringValue:
		return v.StringValue, nil
	}

	return nil, fmt.Errorf("unexpected value type: %T", msg.GetValue())
}

func printEffect(prefix string, state *desc.MessageDescriptor, effect *pb.Effect) (string, error) {
	if up := effect.GetUpdate(); up != nil {

		var (
			nilCheck        string
			initializations []string
			lh              string
			rh              string
		)

		if f := up.GetDest(); f != nil {

			allButLast := f.Name[:len(f.Name)-1]
			initializations = make([]string, len(allButLast))

			msgType := state

			for i, name := range allButLast {
				field := msgType.FindFieldByName(name)
				if field == nil {
					return "", fmt.Errorf("no field under the path %s found in the state message description", strings.Join(f.Name[:i+1], "."))
				}

				if msgType = field.GetMessageType(); msgType == nil {
					return "", fmt.Errorf("failed to look up message type for field %s in the state message description", strings.Join(f.Name[:i+1], ","))
				}

				typeName := goNames.GoTypeOfField(field).String()

				isPtr := strings.HasPrefix(typeName, "*")
				if !isPtr {
					// no initialization needed since the
					// field is a not a pointer.
					continue
				}

				typeName = typeName[1:]

				parts := strings.Split(typeName, ".")

				switch len(parts) {
				case 1:
				case 2:
					// remove the package name prefix.
					typeName = parts[1]
				default:
					return "", fmt.Errorf("type name has more that one '.': %s", typeName)
				}

				fullStateFieldName := fmt.Sprintf("%s.%s", prefix, joinCamelCase(allButLast[:i+1]))

				initializations = append(initializations, `
					if `+fullStateFieldName+` == nil {
						`+fullStateFieldName+` = &`+typeName+`{}
					}
				`)

			}

			lh = fmt.Sprintf("%s.%s", prefix, joinCamelCase(f.Name))

		} else {
			return "", fmt.Errorf("no field specified to be set in update")
		}

		if f := up.GetSrcField(); f != nil {

			allButLast := f.Name[:len(f.Name)-1]
			nilChecks := make([]string, len(allButLast))
			for i := range allButLast {
				nilChecks[i] = fmt.Sprintf("(%s.%s != nil)", prefix, joinCamelCase(f.Name[:i+1]))
			}
			nilCheck = strings.Join(nilChecks, " && ")

			rh = fmt.Sprintf("%s.%s", prefix, joinCamelCase(f.Name))

		} else if v := up.GetSrcValue(); v != nil {

			val, err := extractValue(v)
			if err != nil {
				return "", err
			}

			rh = fmt.Sprint(val)

		} else {
			return "", fmt.Errorf("no field or value specified to update with")
		}

		res := lh + " = " + rh

		if nilCheck != "" {
			res = `if ` + nilCheck + ` { ` + res + ` }`
		}

		return strings.Join(initializations, "\n") + "\n\n" + res, nil
	}

	return "", fmt.Errorf("no effect specified")
}
