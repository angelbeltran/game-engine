package main

import (
	"fmt"
	"strings"
	"text/template"

	"github.com/jhump/goprotoc/plugins"
	"github.com/jhump/protoreflect/desc"

	pb "angelbeltran/game-engine/protoc-gen-game/game_engine_pb"
)

type mainTemplateParameters struct {
	Package string
	Imports []string
	Service *desc.ServiceDescriptor
	Methods []methodBundle
	State   *desc.MessageDescriptor
}

var defaultMethodImports = []string{
	"context",
	"fmt",
	"net",
	"sync",
	"google.golang.org/grpc",
	"angelbeltran/game-engine/protoc-gen-game/game_engine_pb",
}

var mainTemplate = template.Must(template.New("main").Funcs(template.FuncMap{
	"joinCamelCase": joinCamelCase,
	"printRule":     printRule,
	"printEffect":   printEffect,
}).Parse(`
// Generated by protoc-gen-game. DO NOT EDIT.
package {{.Package}}

import (
{{range $_, $import := .Imports}}	{{printf "%q" $import}}
{{end}}
)

func NewServer(port uint) (*grpc.Server, net.Listener, error) {
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
	if err != nil {
		return nil, nil, err
	}

	srv := grpc.NewServer()
	Register{{.Service.GetName}}Server(srv, new(gameEngine))

	return srv, lis, nil
}

type gameEngine struct {
	Unimplemented{{.Service.GetName}}Server
}

{{$state := .State}}
{{range $_, $bundle := .Methods}}
func (e *gameEngine) {{$bundle.Method.GetName}}(ctx context.Context, in *{{$bundle.Method.GetInputType.GetName}}) (*game_engine_pb.Error, error) {
	{{with $action := $bundle.Action}}
		state.Lock()
		defer state.Unlock()

		allowed := {{printRule "state" "in" $action.Rule}}
		if !allowed {
			return &game_engine_pb.Error{
				Code: {{printf "%q" $action.Error.Code}},
				Msg: {{printf "%q" $action.Error.Msg}},
			}, nil
		}

		{{range $_, $effect := $action.Effect}}
		{{printEffect "state" "in" $state $effect}}
		{{end}}

		return &game_engine_pb.Error{}, nil

	{{else}}

		return &game_engine_pb.Error{
			Msg: "unimplemented",
		}, nil

	{{end}}
}
{{end}}

var state struct{
	{{.State.GetName}}
	sync.Mutex
}
`))

var goNames plugins.GoNames

func printRule(statePrefix, inputPrefix string, rule *pb.Rule) (string, error) {
	if s := rule.GetSingle(); s != nil {
		var op string

		switch v := s.GetOperator(); v {
		case pb.Rule_Single_EQ:
			op = "=="
		case pb.Rule_Single_NEQ:
			op = "!="
		case pb.Rule_Single_LT:
			op = "<"
		case pb.Rule_Single_LTE:
			op = "<="
		case pb.Rule_Single_GT:
			op = ">"
		case pb.Rule_Single_GTE:
			op = ">="
		default:
			return "", fmt.Errorf("unexpected operator: %s", v)
		}

		lh, err := printOperandWithNilChecks(statePrefix, inputPrefix, s.GetLeft())
		if err != nil {
			return "", err
		}

		rh, err := printOperandWithNilChecks(statePrefix, inputPrefix, s.GetRight())
		if err != nil {
			return "", err
		}

		return fmt.Sprintf("%s %s %s", lh, op, rh), nil
	}

	if and := rule.GetAnd(); and != nil {
		printed := make([]string, len(and.Rules))

		for i, r := range and.Rules {
			str, err := printRule(statePrefix, inputPrefix, r)
			if err != nil {
				return "", err
			}

			printed[i] = "(" + str + ")"
		}

		return strings.Join(printed, " && "), nil
	}

	if or := rule.GetOr(); or != nil {
		printed := make([]string, len(or.Rules))

		for i, r := range or.Rules {
			str, err := printRule(statePrefix, inputPrefix, r)
			if err != nil {
				return "", err
			}

			printed[i] = "(" + str + ")"
		}

		return strings.Join(printed, " || "), nil
	}

	return "", fmt.Errorf("empty rule definition")
}

func printOperandWithNilChecks(statePrefix, inputPrefix string, op *pb.Operand) (string, error) {
	if v := op.GetValue(); v != nil {
		_, val, err := extractValue(v)
		if err != nil {
			return "", err
		}

		return fmt.Sprint(val), nil
	}

	if p := op.GetProp(); p != nil {
		allButLast := p.Path[:len(p.Path)-1]

		nilChecks := make([]string, len(allButLast))
		for i := range allButLast {
			nilChecks[i] = fmt.Sprintf("%s.%s != nil", statePrefix, joinCamelCase(p.Path[:i+1]))
		}

		return strings.Join(append(nilChecks, fmt.Sprintf("%s.%s", statePrefix, joinCamelCase(p.Path))), " && "), nil
	}

	if in := op.GetInput(); in != nil {
		allButLast := in.Path[:len(in.Path)-1]

		nilChecks := make([]string, len(allButLast))
		for i := range allButLast {
			nilChecks[i] = fmt.Sprintf("%s.%s != nil", inputPrefix, joinCamelCase(in.Path[:i+1]))
		}

		return strings.Join(append(nilChecks, fmt.Sprintf("%s.%s", inputPrefix, joinCamelCase(in.Path))), " && "), nil
	}

	return "", fmt.Errorf("undefined operand")
}

func joinCamelCase(a []string) string {
	b := make([]string, len(a))
	for i, s := range a {
		b[i] = goNames.CamelCase(s)
	}
	return strings.Join(b, ".")
}

func printEffect(statePrefix, inputPrefix string, state *desc.MessageDescriptor, effect *pb.Effect) (string, error) {
	if up := effect.GetUpdate(); up != nil {
		return printUpdateEffect(statePrefix, inputPrefix, state, up)
	}

	return "", fmt.Errorf("no effect specified")
}

func printUpdateEffect(statePrefix, inputPrefix string, state *desc.MessageDescriptor, up *pb.Effect_Update) (string, error) {
	var (
		nilCheck        string
		initializations []string
		lh              string
		rh              string
	)

	dst := up.GetDest()
	if dst == nil {
		return "", fmt.Errorf("no property specified to be set in update")
	}

	allButLast := dst.Path[:len(dst.Path)-1]
	initializations = make([]string, len(allButLast))

	msgType := state

	for i, name := range allButLast {
		field := msgType.FindFieldByName(name)
		if field == nil {
			return "", fmt.Errorf("no field under the path %s found in the state message description", strings.Join(dst.Path[:i+1], "."))
		}

		if msgType = field.GetMessageType(); msgType == nil {
			return "", fmt.Errorf("failed to look up message type for field %s in the state message description", strings.Join(dst.Path[:i+1], ","))
		}

		typeName := goNames.GoTypeOfField(field).String()

		if !strings.HasPrefix(typeName, "*") {
			// no initialization needed since the
			// field is a not a pointer.
			continue
		}

		typeName = typeName[1:]

		parts := strings.Split(typeName, ".")

		switch len(parts) {
		case 1:
		case 2:
			// remove the package name prefix.
			typeName = parts[1]
		default:
			return "", fmt.Errorf("type name has more that one '.': %s", typeName)
		}

		fullStateFieldName := fmt.Sprintf("%s.%s", statePrefix, joinCamelCase(allButLast[:i+1]))

		initializations = append(initializations, `
					if `+fullStateFieldName+` == nil {
						`+fullStateFieldName+` = &`+typeName+`{}
					}
				`)

	}

	lh = fmt.Sprintf("%s.%s", statePrefix, joinCamelCase(dst.Path))

	src := up.GetSrc()
	if src == nil {
		return "", fmt.Errorf("no source specified to update with")
	}

	if v := src.GetValue(); v != nil {
		_, val, err := extractValue(v)
		if err != nil {
			return "", err
		}

		rh = fmt.Sprint(val)
	} else {
		var p *pb.Path
		var prefix string

		if p = src.GetProp(); p != nil {
			prefix = statePrefix
		} else if p = src.GetInput(); p != nil {
			prefix = inputPrefix
		} else {
			return "", fmt.Errorf("no source property or value specified to update with")
		}

		allButLast := p.Path[:len(p.Path)-1]
		nilChecks := make([]string, len(allButLast))
		for i := range allButLast {
			nilChecks[i] = fmt.Sprintf("(%s.%s != nil)", prefix, joinCamelCase(p.Path[:i+1]))
		}
		nilCheck = strings.Join(nilChecks, " && ")

		rh = fmt.Sprintf("%s.%s", prefix, joinCamelCase(p.Path))
	}

	res := lh + " = " + rh

	if nilCheck != "" {
		res = `if ` + nilCheck + ` { ` + res + ` }`
	}

	return strings.Join(initializations, "\n") + "\n\n" + res, nil
}
