package main

import (
	"fmt"
	"strings"
	"text/template"

	"github.com/jhump/goprotoc/plugins"
	"github.com/jhump/protoreflect/desc"

	pb "angelbeltran/game-engine/protoc-gen-game/game_engine_pb"
)

type mainTemplateParameters struct {
	Package  string
	Imports  []string
	Service  *desc.ServiceDescriptor
	Methods  []methodBundle
	State    *desc.MessageDescriptor
	Response *desc.MessageDescriptor
}

func (mainTemplateParameters) ResponseFieldName() string {
	return goNames.CamelCase(responseFieldName)
}

func (mainTemplateParameters) ResponseStateFieldName() string {
	return goNames.CamelCase(responseStateFieldName)
}

func (mainTemplateParameters) ResponseErrorFieldName() string {
	return goNames.CamelCase(responseErrorFieldName)
}

var defaultMethodImports = []string{
	"context",
	"fmt",
	"net",
	"sync",
	"google.golang.org/grpc",
	"angelbeltran/game-engine/protoc-gen-game/game_engine_pb",
}

var mainTemplate = template.Must(template.New("main").Funcs(template.FuncMap{
	"printRule":                     printRule,
	"printEffect":                   printEffect,
	"printResponseAppendExpression": printResponseAppendExpression,
}).Parse(`
// Generated by protoc-gen-game. DO NOT EDIT.
package {{.Package}}

import (
{{range $_, $import := .Imports}}	{{printf "%q" $import}}
{{end}}
)

func NewServer(port uint) (*grpc.Server, net.Listener, error) {
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
	if err != nil {
		return nil, nil, err
	}

	srv := grpc.NewServer()
	Register{{.Service.GetName}}Server(srv, new(gameEngine))

	return srv, lis, nil
}

type gameEngine struct {
	Unimplemented{{.Service.GetName}}Server
}

{{$responseStateFieldName := .ResponseStateFieldName}}
{{$responseErrorFieldName := .ResponseErrorFieldName}}
{{$state := .State}}
{{$responseType := .Response.GetName}}
{{range $_, $bundle := .Methods}}
func (e *gameEngine) {{$bundle.Method.GetName}}(ctx context.Context, in *{{$bundle.Method.GetInputType.GetName}}) (*{{$responseType}}, error) {
	{{with $action := $bundle.Action}}
		state.Lock()
		defer state.Unlock()

		// Enforce the rules
		allowed := {{printRule "state" "in" $action.Rule}}
		if !allowed {
			return &{{$responseType}}{
				{{$responseErrorFieldName}}: &game_engine_pb.Error{
					Code: {{printf "%q" $action.Error.Code}},
					Msg: {{printf "%q" $action.Error.Msg}},
				},
			}, nil
		}

		// Apply any effects
		{{range $_, $effect := $action.Effect}}
		{{printEffect "state" "in" $state $effect}}
		{{end}}

		// Construct the response
		res := {{$responseType}}{
			{{$responseStateFieldName}}: new({{$state.GetName}}),
		}

		{{range $_, $response := $action.Response}}
		{{printResponseAppendExpression (print "res." $responseStateFieldName) "state" $state $response.Path}}
		{{end}}

		return &res, nil

	{{else}}

		return &{{$responseType}}{
			{{$responseErrorFieldName}}: &game_engine_pb.Error{
				Msg: "unimplemented",
			},
		}, nil

	{{end}}
}
{{end}}

var state struct{
	{{.State.GetName}}
	sync.Mutex
}
`))

var goNames plugins.GoNames

func printRule(statePrefix, inputPrefix string, rule *pb.Rule) (string, error) {
	if s := rule.GetSingle(); s != nil {
		var op string

		switch v := s.GetOperator(); v {
		case pb.Rule_Single_EQ:
			op = "=="
		case pb.Rule_Single_NEQ:
			op = "!="
		case pb.Rule_Single_LT:
			op = "<"
		case pb.Rule_Single_LTE:
			op = "<="
		case pb.Rule_Single_GT:
			op = ">"
		case pb.Rule_Single_GTE:
			op = ">="
		default:
			return "", fmt.Errorf("unexpected operator: %s", v)
		}

		lh, err := printOperandWithNilChecks(statePrefix, inputPrefix, s.GetLeft())
		if err != nil {
			return "", err
		}

		rh, err := printOperandWithNilChecks(statePrefix, inputPrefix, s.GetRight())
		if err != nil {
			return "", err
		}

		return fmt.Sprintf("%s %s %s", lh, op, rh), nil
	}

	if and := rule.GetAnd(); and != nil {
		printed := make([]string, len(and.Rules))

		for i, r := range and.Rules {
			str, err := printRule(statePrefix, inputPrefix, r)
			if err != nil {
				return "", err
			}

			printed[i] = "(" + str + ")"
		}

		return strings.Join(printed, " && "), nil
	}

	if or := rule.GetOr(); or != nil {
		printed := make([]string, len(or.Rules))

		for i, r := range or.Rules {
			str, err := printRule(statePrefix, inputPrefix, r)
			if err != nil {
				return "", err
			}

			printed[i] = "(" + str + ")"
		}

		return strings.Join(printed, " || "), nil
	}

	return "", fmt.Errorf("empty rule definition")
}

func printOperandWithNilChecks(statePrefix, inputPrefix string, op *pb.Operand) (string, error) {
	if v := op.GetValue(); v != nil {
		_, val, err := extractValue(v)
		if err != nil {
			return "", err
		}

		return fmt.Sprint(val), nil
	}

	if p := op.GetProp(); p != nil {
		allButLast := p.Path[:len(p.Path)-1]

		nilChecks := make([]string, len(allButLast))
		for i := range allButLast {
			nilChecks[i] = fmt.Sprintf("%s.%s != nil", statePrefix, joinCamelCase(p.Path[:i+1]))
		}

		return strings.Join(append(nilChecks, fmt.Sprintf("%s.%s", statePrefix, joinCamelCase(p.Path))), " && "), nil
	}

	if in := op.GetInput(); in != nil {
		allButLast := in.Path[:len(in.Path)-1]

		nilChecks := make([]string, len(allButLast))
		for i := range allButLast {
			nilChecks[i] = fmt.Sprintf("%s.%s != nil", inputPrefix, joinCamelCase(in.Path[:i+1]))
		}

		return strings.Join(append(nilChecks, fmt.Sprintf("%s.%s", inputPrefix, joinCamelCase(in.Path))), " && "), nil
	}

	return "", fmt.Errorf("undefined operand")
}

func printEffect(statePrefix, inputPrefix string, state *desc.MessageDescriptor, effect *pb.Effect) (string, error) {
	if up := effect.GetUpdate(); up != nil {
		return printUpdateEffect(statePrefix, inputPrefix, state, up)
	}

	return "", fmt.Errorf("no effect specified")
}

func printUpdateEffect(statePrefix, inputPrefix string, state *desc.MessageDescriptor, up *pb.Effect_Update) (string, error) {
	var (
		nilCheck        string
		initializations []string
		lh              string
		rh              string
	)

	// Build the left-hand expression, to update the state.
	// But first, initialize the state as needed.

	dst := up.GetDest()
	if dst == nil {
		return "", fmt.Errorf("no property specified to be set in update")
	}

	initializations, err := printInitializeStatePropertyExpression(statePrefix, state, dst.Path)
	if err != nil {
		return "", fmt.Errorf("failed to print state property initialization expression: %w", err)
	}

	lh = fmt.Sprintf("%s.%s", statePrefix, joinCamelCase(dst.Path))

	// Build the right-hand side expression.

	src := up.GetSrc()
	if src == nil {
		return "", fmt.Errorf("no source specified to update with")
	}

	if v := src.GetValue(); v != nil {
		_, val, err := extractValue(v)
		if err != nil {
			return "", err
		}

		rh = fmt.Sprint(val)
	} else {
		var p *pb.Path
		var prefix string

		if p = src.GetProp(); p != nil {
			prefix = statePrefix
		} else if p = src.GetInput(); p != nil {
			prefix = inputPrefix
		} else {
			return "", fmt.Errorf("no source property or value specified to update with")
		}

		nilChecks := make([]string, len(p.Path)-1)
		for i := range nilChecks {
			nilChecks[i] = fmt.Sprintf("(%s.%s != nil)", prefix, joinCamelCase(p.Path[:i+1]))
		}
		nilCheck = strings.Join(nilChecks, " && ")

		rh = fmt.Sprintf("%s.%s", prefix, joinCamelCase(p.Path))
	}

	res := lh + " = " + rh

	// TODO: instead of conditionally applying the update, fail if the nil checks don't pass.
	if nilCheck != "" {
		res = `if ` + nilCheck + ` { ` + res + ` }`
	}

	return strings.Join(initializations, "\n") + "\n\n" + res, nil
}

func printResponseAppendExpression(responsePrefix, statePrefix string, state *desc.MessageDescriptor, path []string) (string, error) {
	initializations, err := printInitializeStatePropertyExpression(responsePrefix, state, path)
	if err != nil {
		return "", fmt.Errorf("failed to print response property initialization expression: %w", err)
	}

	initializeParentFields := strings.Join(initializations, "\n")
	resolvedProperty := joinCamelCase(path)
	setField := fmt.Sprintf("%s.%s = %s.%s", responsePrefix, resolvedProperty, statePrefix, resolvedProperty)

	return initializeParentFields + "\n" + setField, nil
}

func printInitializeStatePropertyExpression(identifier string, state *desc.MessageDescriptor, path []string) ([]string, error) {
	allButLast := path[:len(path)-1]
	initializations := make([]string, len(allButLast))

	msgType := state

	for i, name := range allButLast {
		field := msgType.FindFieldByName(name)
		if field == nil {
			return nil, fmt.Errorf("no field under the path %s found in the state message description", strings.Join(path[:i+1], "."))
		}

		if msgType = field.GetMessageType(); msgType == nil {
			return nil, fmt.Errorf("failed to look up message type for field %s in the state message description", strings.Join(path[:i+1], ","))
		}

		typeName := goNames.GoTypeOfField(field).String()

		if !strings.HasPrefix(typeName, "*") {
			// no initialization needed since the
			// field is a not a pointer.
			continue
		}

		typeName = typeName[1:]

		parts := strings.Split(typeName, ".")

		switch len(parts) {
		case 1:
		case 2:
			// remove the package name prefix.
			typeName = parts[1]
		default:
			return nil, fmt.Errorf("type name has more that one '.': %s", typeName)
		}

		fullResponseFieldName := fmt.Sprintf("%s.%s", identifier, joinCamelCase(allButLast[:i+1]))

		initializations = append(initializations, `
			if `+fullResponseFieldName+` == nil {
				`+fullResponseFieldName+` = &`+typeName+`{}
			}
		`)
	}

	return initializations, nil
}

func joinCamelCase(a []string) string {
	b := make([]string, len(a))
	for i, s := range a {
		b[i] = goNames.CamelCase(s)
	}
	return strings.Join(b, ".")
}
