package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"strings"
	"text/template"

	"github.com/jhump/protoreflect/desc"
	"github.com/jhump/goprotoc/plugins"

	pb "github.com/angelbeltran/game-engine/protoc-gen-game/game_engine_pb"
)

{{- $types := .Types }}

func GenerateService(w io.Writer, opts TemplateParams) error {

	// Parse template.

	tmpl, err := template.New("main").Funcs(template.FuncMap{
		"camelCase": (&plugins.GoNames{}).CamelCase,
		"goTypeOfField": (&plugins.GoNames{}).GoTypeOfField,
		"failNoFunctionName": failNoFunctionName,
		"split": strings.Split,
		"errBadTypeName": func(typeName string) (interface{}, error) {
			return nil, fmt.Errorf("type name has more that one '.': %s", typeName)
		},
		"NewMessageInitializer": NewMessageInitializer,
		"NewReferenceParams": NewReferenceParams,
		"NewValueParams": NewValueParams,
		{{- range $_, $type := $types }}
		{{- $ident := printf "New%sValueParams" (capitalize $type) }}
		"{{ $ident }}": {{ $ident }},
		{{- end }}
		{{- range $_, $domain := $types }}
		{{- range $_, $codomain := $types }}
		{{- $ident := printf "New%sTo%sFunctionParams" (capitalize $domain) (capitalize $codomain) }}
		"{{ $ident }}": {{ $ident }},
		{{- end }}
		{{- end }}
		{{- range $_, $domain1 := $types }}
		{{- range $_, $domain2 := $types }}
		{{- range $_, $codomain := $types }}
		{{- $ident := printf "New%sAnd%sTo%sFunctionParams" (capitalize $domain1) (capitalize $domain2) (capitalize $codomain) }}
		"{{ $ident }}": {{ $ident }},
		{{- end }}
		{{- end }}
		{{- end }}
	}).Parse(Template)
	if err != nil {
		return fmt.Errorf("failed to parse service template: %w", err)
	}

	// Apply runtime parameters.

	out := bytes.NewBuffer([]byte{})

	if err := tmpl.Execute(out, opts); err != nil {
		return fmt.Errorf("failed to execute service template: %w", err)
	}

	// Format and write to file.

	b, err := ioutil.ReadAll(out)
	if err != nil {
		return fmt.Errorf("failed to read unformated templates: %w", err)
	}

	b, err = format.Source(b)
	if err != nil {
		return fmt.Errorf("failed to format generated templates: %w", err)
	}

	if _, err := w.Write(b); err != nil {
		return fmt.Errorf("failed to write out formatted templates: %w", err)
	}

	return nil
}

// TemplateParams hold all the arguments needed for the main template.
type TemplateParams struct {
	Package                         string
	Imports                         []string
	Service                         *desc.ServiceDescriptor
	Methods                         []MethodInfo
	State                           *desc.MessageDescriptor
	Response                        *desc.MessageDescriptor
	StateVariable                   string
	InputVariable                   string
	ResponseErrorField              string
}

// MethodInfo is a method and action pair.
type MethodInfo struct {
	Method *desc.MethodDescriptor
	Action *pb.Action
}

const Template = `{{`// Generated by protoc-gen-game. DO NOT EDIT.
package {{ .Package }}

import (
{{ range $_, $import := .Imports }}	{{ printf "%q" $import }}
	"github.com/angelbeltran/game-engine/protoc-gen-game/proto-generation/go_func"
{{ end }}
)

func NewServer(port uint) (*grpc.Server, net.Listener, error) {
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
	if err != nil {
		return nil, nil, err
	}

	srv := grpc.NewServer()
	Register{{ .Service.GetName }}Server(srv, new(gameEngine))

	return srv, lis, nil
}

type gameEngine struct {
	Unimplemented{{ .Service.GetName }}Server
}

{{- $state := .State }}
{{- $responseType := .Response.GetName }}
{{- $responseErrorField := .ResponseErrorField }}
{{- $stateVariable := .StateVariable }}
{{- $inputVariable := .InputVariable }}
{{- range $_, $bundle := .Methods }}
func (e *gameEngine) {{ $bundle.Method.GetName }}(ctx context.Context, in *{{ $bundle.Method.GetInputType.GetName }}) (*{{ $responseType }}, error) {
	{{- with $action := $bundle.Action -}}
		state.Lock()
		defer state.Unlock()

		// Enforce the rules
		allowed := {{ template "BoolValue" NewBoolValueParams $action.Rule $inputVariable $stateVariable }}
		if !allowed {
			return &{{ $responseType }}{
				{{ $responseErrorField }}: &game_engine_pb.Error{
					Code: {{ printf "%q" $action.Error.Code }},
					Msg: {{ printf "%q" $action.Error.Msg }},
				},
			}, nil
		}

		// TODO: Apply any effects

		// TODO: Construct the response

		return &{{ $responseType }}{}, nil

	{{- else }}

		return &{{ $responseType }}{
			{{ $responseErrorField }}: &game_engine_pb.Error{
				Msg: "unimplemented",
			},
		}, nil

	{{- end }}
}
{{- end }}

type GameState struct {
	{{ .State.GetName }}
	sync.Mutex
}

func NewGameState() GameState {
	var s GameState
	
	{{ template "initialize" NewMessageInitializer (printf "s.%s" .State.GetName) .State }}

	return s
}

var state = NewGameState()

{{- define "initialize" }}
{{/* Expects MessageInitializer */}}
	{{- $ident := .Identifier }}

	{{- range $field := .MessageDescriptor.GetFields }}
		{{- if or $field.GetMessageType $field.IsMap }}
			{{- $typeName := (goTypeOfField $field).String }}

			{{- $isPointer := eq (index $typeName 0) '*' }}
			{{- if $isPointer }}
				{{- $typeName = slice $typeName 1 }}
			{{- end }}

			{{- $parts := split $typeName "." }}
			{{- $n := len $parts }}
			{{- if or (eq $n 0) (gt $n 2 )}}
				{{- errBadTypeName $typeName }}
			{{- else if eq $n 2 }}
				{{- $typeName = index $parts 1 }}
			{{- end }}

			{{- if $field.GetMessageType }}
				{{- $lh := printf "%s.%s"  $ident (camelCase $field.GetName) }}

				{{- if $isPointer }}
		{{- $lh }} = new({{ $typeName }})
				{{- end }}

				{{- template "initialize" NewMessageInitializer $lh $field.GetMessageType }}

			{{- else }}
				{{- $lh := printf "%s.%s"  $ident (camelCase $field.GetName) }}

				{{- if $isPointer }}
		{{- $lh }} = make({{ $typeName }})
				{{- end }}

			{{- end }}

		{{- end }}
	{{- end }}
{{- end }}

`}}

{{ `{{/* Expression Evaluations */}}` }}

{{`{{- define "Reference" }}
{{- /* Expects a ReferenceParams */}}
{{ .Variable }}{{ range $_, $field := .Reference.Path }}.{{ camelCase $field }}{{ end }}
{{- end }}`}}

{{- /* Value Templates */}}

{{`{{- define "Value" }}`}}
{{- /* Expects a ValueParams */}}
{{- range $i, $type := $types }}
{{- $type = capitalize $type }}
{{- $valueType := printf "%sValue" $type }}
{{ "{{-" }} {{ if $i }}else {{ end }}if .Value.{{ $valueType }} {{ "}}{{" }} template "{{ $valueType }}" New{{ $valueType }}Params .Value.{{ $type }}Value .InputVariable .StateVariable {{ "}}" }}
{{- end }}
{{ "{{- end }}" }}
{{`{{- end }}`}}

{{- range $_, $type := $types }}
{{- $type = capitalize $type }}
{{- $valueType := printf "%sValue" $type }}

{{ printf `{{- define "%s" }}` $valueType }}
{{ `{{-` }} /* Expects a {{ $valueType }}Params */{{ `}}` }}
{{ "{{-" }} if .Value.GetInput {{ "}}{{" }} template "Reference" NewReferenceParams .InputVariable .Value.GetInput {{ "}}" }}
{{ "{{-" }} else if .Value.GetState {{ "}}{{" }} template "Reference" NewReferenceParams .StateVariable .Value.GetState {{ "}}" }}

{{- range $_, $domain := $types }}
{{- $domain = capitalize $domain }}
{{- $getter := printf ".Value.Get%sFunc" $domain }}
{{ "{{-" }} else if {{ $getter }} {{ "}}{{" }} template "{{ $domain }}To{{ $type }}Function" New{{ $domain }}To{{ $type }}FunctionParams {{ $getter }} .InputVariable .StateVariable {{ "}}" }}
{{- end }}

{{- range $_, $domain1 := $types }}
{{- $domain1 = capitalize $domain1 }}
{{- range $_, $domain2 := $types }}
{{- $domain2 = capitalize $domain2 }}
{{ "{{-" }} else if .Value.Get{{ $domain1 }}{{ $domain2 }}Func {{ "}}{{" }} template "{{ $domain1 }}And{{ $domain2 }}To{{ $type }}Function" New{{ $domain1 }}And{{ $domain2 }}To{{ $type }}FunctionParams .Value.Get{{ $domain1 }}{{ $domain2 }}Func .InputVariable .StateVariable {{ "}}" }}
{{- end }}
{{- end }}
{{ `{{-` }} else if .Value.GetIf {{ `}}{{` }} template "{{ $type }}ValueIf" New{{ $type }}ValueParams .Value.GetIf .InputVariable .StateVariable {{ `}}` }}
{{ "{{-" }} else {{ "}}{{" }} .Value.GetConstant {{ "}}" }}
{{`{{- end }}`}}
{{`{{- end }}`}}

{{- end }}


{{ `{{- /* Unary Function Templates */}}` }}

{{ range $_, $domain := $types }}
{{- $domain = capitalize $domain }}
{{- range $_, $codomain := $types }}
{{- $codomain = capitalize $codomain }}
{{- $funcTypeName := printf "%sTo%sFunction" $domain $codomain }}
{{ `{{-` }} define "{{ $funcTypeName }}" {{ `-}}` }}
{{ `{{- /*`}} Expects a {{ $funcTypeName }}Params {{ `*/}}` }}
{{ `{{-` }} if not .Function.Name {{ `}}{{` }} failNoFunctionName "{{ $funcTypeName }}" {{ `}}{{` }} end {{ `}}` -}}
go_func.{{- $domain }}To{{ $codomain }}_{{ `{{- camelCase .Function.Name.String }}(` }}
	{{ `{{-` }} if .Function.GetInput {{ `}}{{` }} template "Reference" NewReferenceParams .InputVariable .Function.GetInput {{ `}}` }}
	{{ `{{-` }} else if .Function.GetState {{ `}}{{` }} template "Reference" NewReferenceParams .StateVariable .Function.GetState {{ `}}` }}

	{{- /* Unary function output at input */}}
	{{- range $fieldDomain := $types }}
	{{- $fieldDomain = capitalize $fieldDomain }}
	{{- $funcFieldName := printf "%sFunc" $fieldDomain }}
	{{- $nestedFuncTypeName := printf "%sTo%sFunction" $fieldDomain $domain }}
	{{- $getter := printf ".Function.Get%s" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}

	{{- /* Binary function output at input */}}
	{{- range $fieldDomain1 := $types }}
	{{- $fieldDomain1 = capitalize $fieldDomain1 }}
	{{- range $fieldDomain2 := $types }}
	{{- $fieldDomain2 = capitalize $fieldDomain2 }}
	{{- $funcFieldName := printf "%s%sFunc" $fieldDomain1 $fieldDomain2 }}
	{{- $nestedFuncTypeName := printf "%sAnd%sTo%sFunction" $fieldDomain1 $fieldDomain2 $domain }}
	{{- $getter := printf ".Function.Get%s" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}
	{{- end }}

	{{ `{{-` }} else if .If {{ `}}{{` }} template "{{ $domain }}ValueIf" New{{ $domain }}ValueParams .If .InputVariable .StateVariable {{ `}}` }}

	{{ `{{-` }} end {{ `}}` }},
{{ `)` }}
{{ `{{-` }} end {{ `}}` }}
{{ end }}
{{- end }}


{{ `{{/* Binary Function Templates */}}` }}

{{ range $_, $domain1 := $types }}
{{- $domain1 = capitalize $domain1 }}
{{- range $_, $domain2 := $types }}
{{- $domain2 = capitalize $domain2 }}
{{- range $_, $codomain := $types }}
{{- $codomain = capitalize $codomain }}
{{- $funcTypeName := printf "%sAnd%sTo%sFunction" $domain1 $domain2 $codomain }}
{{ `{{-` }} define "{{ $funcTypeName }}" {{ `-}}` }}
{{ `{{- /*`}} Expects a {{ $funcTypeName }}Params {{ `*/}}` }}
{{ `{{-` }} if not .Function.Name {{ `}}{{` }} failNoFunctionName "{{ $funcTypeName }}" {{ `}}{{` }} end {{ `}}` }}
go_func.{{- $domain1 }}And{{ $domain2 }}To{{ $codomain }}_{{ `{{- camelCase .Function.Name.String }}(` }}
	{{ `{{-` }} if .Function.GetInput_1 {{ `}}{{` }} template "Reference" NewReferenceParams .InputVariable .Function.GetInput_1 {{ `}}` }}
	{{ `{{-` }} else if .Function.GetState_1 {{ `}}{{` }} template "Reference" NewReferenceParams .StateVariable .Function.GetState_1 {{ `}}` }}

	{{- /* Unary function output at input 1 */}}
	{{- range $fieldDomain := $types }}
	{{- $fieldDomain = capitalize $fieldDomain }}
	{{- $funcFieldName := printf "%sFunc" $fieldDomain }}
	{{- $nestedFuncTypeName := printf "%sTo%sFunction" $fieldDomain $domain1 }}
	{{- $getter := printf ".Function.Get%s_1" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}

	{{- /* Binary function output at input 1 */}}
	{{- range $fieldDomain1 := $types }}
	{{- $fieldDomain1 = capitalize $fieldDomain1 }}
	{{- range $fieldDomain2 := $types }}
	{{- $fieldDomain2 = capitalize $fieldDomain2 }}
	{{- $funcFieldName := printf "%s%sFunc" $fieldDomain1 $fieldDomain2 }}
	{{- $nestedFuncTypeName := printf "%sAnd%sTo%sFunction" $fieldDomain1 $fieldDomain2 $domain1 }}
	{{- $getter := printf ".Function.Get%s_1" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}
	{{- end }}

	{{ `{{-` }} else if .Function.GetIf_1 {{ `}}{{` }} template "{{ $domain1 }}ValueIf" New{{ $domain1 }}ValueParams .Function.GetIf_1 .InputVariable .StateVariable {{ `}}` }}

	{{ `{{-` }} end {{ `}}` }},

	{{ `{{-` }} if .Function.GetInput_2 {{ `}}{{` }} template "Reference" NewReferenceParams .InputVariable .Function.GetInput_2 {{ `}}` }}
	{{ `{{-` }} else if .Function.GetState_2 {{ `}}{{` }} template "Reference" NewReferenceParams .StateVariable .Function.GetState_2 {{ `}}` }}

	{{- /* Unary function output at input 2 */}}
	{{- range $fieldDomain := $types }}
	{{- $fieldDomain = capitalize $fieldDomain }}
	{{- $funcFieldName := printf "%sFunc" $fieldDomain }}
	{{- $nestedFuncTypeName := printf "%sTo%sFunction" $fieldDomain $domain2 }}
	{{- $getter := printf ".Function.Get%s_2" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}

	{{- /* Binary function output at input 2 */}}
	{{- range $fieldDomain1 := $types }}
	{{- $fieldDomain1 = capitalize $fieldDomain1 }}
	{{- range $fieldDomain2 := $types }}
	{{- $fieldDomain2 = capitalize $fieldDomain2 }}
	{{- $funcFieldName := printf "%s%sFunc" $fieldDomain1 $fieldDomain2 }}
	{{- $nestedFuncTypeName := printf "%sAnd%sTo%sFunction" $fieldDomain1 $fieldDomain2 $domain2 }}
	{{- $getter := printf ".Function.Get%s_2" $funcFieldName }}
	{{ `{{-` }} else if {{ $getter }} {{ `}}{{` }} template "{{ $nestedFuncTypeName }}" New{{ $nestedFuncTypeName }}Params {{ $getter }} .InputVariable .StateVariable {{ `}}` }}
	{{- end }}
	{{- end }}

	{{ `{{-` }} else if .Function.GetIf_2 {{ `}}{{` }} template "{{ $domain2 }}ValueIf" New{{ $domain2 }}ValueParams .Function.GetIf_2 .InputVariable .StateVariable {{ `}}` }}

	{{ `{{-` }} end {{ `}}` }},
{{ `)` }}
{{ `{{-` }} end {{ `}}` }}
{{ end }}
{{ end }}
{{- end }}

{{- /* If-Else control structures */}}

{{- range $type := $types }}
{{- $lowerCaseType := $type }}
{{- $type = capitalize $type }}
{{ `{{-` }} define "{{ $type }}ValueIf" {{ `-}}` }}
{{ `{{- /* Expects a *pb.` }}{{ $type }}{{`ValueIf */}}` }}
func() {{ $lowerCaseType }} {
	if {{ `{{` }} template "BoolValue" NewBoolValueParams .If.Predicate .InputVariable .StateVariable {{ `}}` }} {
		return {{ `{{` }} template "{{ $type }}Value" New{{ $type }}ValueParams .If.Then .InputVariable .StateVariable {{ `}}` }}
	}

	return {{ `{{` }} template "{{ $type }}Value" New{{ $type }}ValueParams .If.Else .InputVariable .StateVariable {{ `}}` }}
}()
{{ `{{-` }} end {{ `}}` }}
{{ end }}
`

// References

type ReferenceParams struct {
	Reference *pb.Reference
	Variable string
}

func NewReferenceParams(variable string, reference *pb.Reference) ReferenceParams {
	return ReferenceParams{
		Variable: variable,
		Reference: reference,
	}
}

// Values

type ValueParams struct {
	Value *pb.Value
}

func NewValueParams(value *pb.Value) ValueParams {
	return ValueParams{
		Value: value,
	}
}
{{ range $_, $type := $types }}
{{- $type = capitalize $type }}
{{- $valueType := printf "%sValue" $type }}
type {{ $valueType }}Params struct {
	Value *pb.{{ $valueType }}
	InputVariable string
	StateVariable string
}

func New{{ $valueType }}Params(value *pb.{{ $valueType }}, input, state string) {{ $valueType }}Params {
	return {{ $valueType }}Params{
		Value: value,
		InputVariable: input,
		StateVariable: state,
	}
}
{{ end }}

// Unary Functions

{{- range $_, $domain := $types }}
{{- $domain = capitalize $domain }}
{{- range $_, $codomain := $types }}
{{- $codomain = capitalize $codomain }}
{{- $funcType := printf "%sTo%sFunction" $domain $codomain }}

type {{ $funcType }}Params struct {
	Function *pb.{{ $funcType }}
	InputVariable string
	StateVariable string
}

func New{{ $funcType }}Params(function *pb.{{ $funcType }}, input, state string) {{ $funcType }}Params {
	return {{ $funcType }}Params{
		Function: function,
		InputVariable: input,
		StateVariable: state,
	}
}
{{- end }}
{{- end }}

// Binary Functions
{{- range $_, $domain1 := $types }}
{{- $domain1 = capitalize $domain1 }}
{{- range $_, $domain2 := $types }}
{{- $domain2 = capitalize $domain2 }}
{{- range $_, $codomain := $types }}
{{- $codomain = capitalize $codomain }}
{{- $funcType := printf "%sAnd%sTo%sFunction" $domain1 $domain2 $codomain }}

type {{ $funcType }}Params struct {
	Function *pb.{{ $funcType }}
	InputVariable string
	StateVariable string
}

func New{{ $funcType }}Params(function *pb.{{ $funcType }}, input, state string) {{ $funcType }}Params {
	return {{ $funcType }}Params{
		Function: function,
		InputVariable: input,
		StateVariable: state,
	}
}
{{- end }}
{{- end }}
{{- end }}

type MessageInitializer struct {
	Identifier string
	MessageDescriptor *desc.MessageDescriptor
}

func NewMessageInitializer(ident string, msg *desc.MessageDescriptor) MessageInitializer {
	return MessageInitializer {
		Identifier: ident,
		MessageDescriptor: msg,
	}
}

func failNoFunctionName(funcType string) (interface{}, error) {
	return nil, fmt.Errorf("function name missing for function type %s", funcType)
}
