package main

const serviceTemplate = `
// Generated by protoc-gen-game. DO NOT EDIT.
package {{.Package}}

import (
{{range $_, $import := .Imports}}	{{printf "%q" $import}}
{{end}}
)

func NewServer(port uint) (*grpc.Server, net.Listener, error) {
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
	if err != nil {
		return nil, nil, err
	}

	srv := grpc.NewServer()
	Register{{.Service.GetName}}Server(srv, new(gameEngine))

	return srv, lis, nil
}

type gameEngine struct {
	Unimplemented{{.Service.GetName}}Server
}

{{$responseStateFieldName := .ResponseStateFieldName}}
{{$responseErrorFieldName := .ResponseErrorFieldName}}
{{$state := .State}}
{{$responseType := .Response.GetName}}
{{range $_, $bundle := .Methods}}
func (e *gameEngine) {{$bundle.Method.GetName}}(ctx context.Context, in *{{$bundle.Method.GetInputType.GetName}}) (*{{$responseType}}, error) {
	{{with $action := $bundle.Action}}
		state.Lock()
		defer state.Unlock()

		// Enforce the rules
		allowed := {{printRule "state" "in" $action.Rule}}
		if !allowed {
			return &{{$responseType}}{
				{{$responseErrorFieldName}}: &game_engine_pb.Error{
					Code: {{printf "%q" $action.Error.Code}},
					Msg: {{printf "%q" $action.Error.Msg}},
				},
			}, nil
		}

		// Apply any effects
		{{range $_, $effect := $action.Effect}}
		{{printEffect "state" "in" $state $effect}}
		{{end}}

		// Construct the response
		res := {{$responseType}}{
			{{$responseStateFieldName}}: new({{$state.GetName}}),
		}

		{{range $_, $response := $action.Response}}
		{{printResponseAppendExpression (print "res." $responseStateFieldName) "state" $state $response.Path}}
		{{end}}

		return &res, nil

	{{else}}

		return &{{$responseType}}{
			{{$responseErrorFieldName}}: &game_engine_pb.Error{
				Msg: "unimplemented",
			},
		}, nil

	{{end}}
}
{{end}}

var state struct{
	{{.State.GetName}}
	sync.Mutex
}
`
