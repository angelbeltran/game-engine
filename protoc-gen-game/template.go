package main

import (
	"fmt"
	"strings"
	"text/template"

	"github.com/jhump/protoreflect/desc"

	pb "github.com/angelbeltran/game-engine/protoc-gen-game/game_engine_pb"
)

//
// Template binding and construction
//

var definitions = definition{
	Name:     "service",
	Template: serviceTemplate,
	Funcs: template.FuncMap{
		"newEffectParams": newEffectParams,
		"newResponseAppendExpressionTemplateParams": newResponseAppendExpressionTemplateParams,
	},
	Definitions: []definition{{
		Name:     "rule",
		Template: ruleTemplate,
		Funcs: template.FuncMap{
			"unexpectedOperator": func(op interface{}) (interface{}, error) {
				return nil, fmt.Errorf("unexpected operator: %s", op)
			},
			"errNoRuleDefined": func() (interface{}, error) {
				return nil, fmt.Errorf("rule empty or missing")
			},
		},
		Definitions: []definition{{
			Name:     "operandWithNilCheck",
			Template: operandWithNilCheckTemplate,
			Funcs: template.FuncMap{
				"inc": func(i int) int {
					return i + 1
				},
				"printValue": func(msg *pb.Value) (interface{}, error) {
					_, v, err := extractValue(msg)
					return v, err
				},
				"joinCamelCase": joinCamelCase,
				"errUndefinedOperand": func() (interface{}, error) {
					return nil, fmt.Errorf("undefined operand")
				},
			},
		}},
	}, {
		Name:     "effect",
		Template: effectTemplate,
		Funcs: template.FuncMap{
			"joinCamelCase": joinCamelCase,
			"printValue": func(msg *pb.Value) (interface{}, error) {
				_, v, err := extractValue(msg)
				return v, err
			},
			"inc": inc,
			"dec": dec,

			"newUpdateEffectParams":                      newUpdateEffectParams,
			"newInitializeStatePropertyExpressionParams": newInitializeStatePropertyExpressionParams,

			"errNoEffectSpecified": func() (interface{}, error) {
				return "", fmt.Errorf("no effect specified")
			},
			"errNoPropertySpecified": func() (interface{}, error) {
				return "", fmt.Errorf("no property specified to be set")
			},
			"errNoSourceSpecified": func() (interface{}, error) {
				return "", fmt.Errorf("no source specified")
			},
			"errNoSourcePropertyOrValue": func() (interface{}, error) {
				return "", fmt.Errorf("no source property or value specified to update with")
			},
		},
		Definitions: []definition{initializeStatePropertyDefinition},
	}, {
		Name:     "responseAppendExpressionTemplate",
		Template: responseAppendExpressionTemplate,
		Funcs: template.FuncMap{
			"newInitializeStatePropertyExpressionParams": newInitializeStatePropertyExpressionParams,
			"joinCamelCase": joinCamelCase,
		},
		Definitions: []definition{initializeStatePropertyDefinition},
	}},
}

var initializeStatePropertyDefinition = definition{
	Name:     "initializeStateProperty",
	Template: initializeStatePropertyExpression,
	Funcs: template.FuncMap{
		"errNoField": func(path []string, i int) (interface{}, error) {
			return nil, fmt.Errorf("no field under the path %s found in the state message description", strings.Join(path[:i+1], "."))
		},
		"errNoMessageType": func(path []string, i int) (interface{}, error) {
			return nil, fmt.Errorf("failed to look up message type for field %s in the state message description", strings.Join(path[:i+1], ","))
		},
		"goTypeOfField": func(field *desc.FieldDescriptor) string {
			return goNames.GoTypeOfField(field).String()
		},
		"split": strings.Split,
		"errBadTypeName": func(typeName string) (interface{}, error) {
			return nil, fmt.Errorf("type name has more that one '.': %s", typeName)
		},
		"joinCamelCase": joinCamelCase,
		"inc":           inc,
		"dec":           dec,
	},
}

type definition struct {
	Name        string
	Funcs       template.FuncMap
	Template    string
	Definitions []definition
}

func parseDefinition(parent *template.Template, def definition) (map[string]*template.Template, error) {
	var tmpl *template.Template
	if parent == nil {
		tmpl = template.New(def.Name)
	} else {
		tmpl = parent.New(def.Name)
	}

	tmpl, err := tmpl.Funcs(def.Funcs).Parse(def.Template)
	if err != nil {
		return nil, fmt.Errorf("failed to parse %s template: %w", def.Name, err)
	}

	res := map[string]*template.Template{
		def.Name: tmpl,
	}

	for _, sub := range def.Definitions {
		m, err := parseDefinition(tmpl, sub)
		if err != nil {
			return nil, err
		}

		for k, v := range m {
			res[k] = v
		}
	}

	return res, nil
}

//
// Templates
//

// expects a serviceParams.
var serviceTemplate = `
// Generated by protoc-gen-game. DO NOT EDIT.
package {{.Package}}

import (
{{range $_, $import := .Imports}}	{{printf "%q" $import}}
{{end}}
)

func NewServer(port uint) (*grpc.Server, net.Listener, error) {
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
	if err != nil {
		return nil, nil, err
	}

	srv := grpc.NewServer()
	Register{{.Service.GetName}}Server(srv, new(gameEngine))

	return srv, lis, nil
}

type gameEngine struct {
	Unimplemented{{.Service.GetName}}Server
}

{{$state := .State}}
{{$responseType := .Response.GetName}}
{{range $_, $bundle := .Methods}}
func (e *gameEngine) {{$bundle.Method.GetName}}(ctx context.Context, in *{{$bundle.Method.GetInputType.GetName}}) (*{{$responseType}}, error) {
	{{- with $action := $bundle.Action -}}
		state.Lock()
		defer state.Unlock()

		// Enforce the rules
		allowed := {{template "rule" $action.Rule}}
		if !allowed {
			return &{{$responseType}}{
				` + responseErrorFieldNameCamelCase + `: &game_engine_pb.Error{
					Code: {{printf "%q" $action.Error.Code}},
					Msg: {{printf "%q" $action.Error.Msg}},
				},
			}, nil
		}

		// Apply any effects
		{{range $_, $effect := $action.Effect}}
		{{template "effect" (newEffectParams $state $effect)}}
		{{end}}

		// Construct the response
		` + responseVariable + ` := {{$responseType}}{
			` + responseStateFieldNameCamelCase + `: new({{$state.GetName}}),
		}

		{{range $_, $response := $action.Response}}
			{{- template "responseAppendExpressionTemplate" (newResponseAppendExpressionTemplateParams $state $response.Path)}}
		{{- end}}

		return &` + responseVariable + `, nil

	{{- else -}}

		return &{{$responseType}}{
			` + responseErrorFieldNameCamelCase + `: &game_engine_pb.Error{
				Msg: "unimplemented",
			},
		}, nil

	{{- end -}}
}
{{end}}

var state struct{
	{{.State.GetName}}
	sync.Mutex
}
`

// expects a *pb.Rule
const ruleTemplate = `
{{- define "operator"}}
	{{- $op := .Operator}}

	{{- if (eq $op 1) -}}		==
	{{- else if (eq $op 2)}}	!=
	{{- else if (eq $op 3)}}	<
	{{- else if (eq $op 4)}}	<=
	{{- else if (eq $op 5)}}	>
	{{- else if (eq $op 6)}}	>=
	{{- else}}{{unexpectedOperator $op}}
	{{- end -}}
{{end}}

{{- define "single"}}
	{{- template "operandWithNilCheck" .Left }} {{template "operator" .}} {{- template "operandWithNilCheck" .Right -}}
{{end}}

{{- define "general"}}
	{{- if .GetSingle}}
		{{- template "single" .GetSingle}}

	{{- else if .GetAnd}}
		{{- range $i, $rule := .GetAnd.Rules}}
			{{- if $i }} && {{end -}}
			({{ template "general" $rule }})
		{{- end}}

	{{- else if .GetOr}}
		{{- range $i, $rule := .GetOr.Rules}}
			{{- if $i }} || {{end -}}
			({{ template "general" $rule }})
		{{- end}}
	{{- else}}{{errNoRuleDefined}}
	{{- end}}
{{- end}}

{{- template "general" . }}
`

// expected a *pb.Operand.
const operandWithNilCheckTemplate = `
{{- define "stateNilChecks" }}
	{{- $path := . }}

	{{- range $i, $_ := $path -}}
		` + stateVariable + `.{{- joinCamelCase (slice $path 0 (inc $i)) }}
		{{- if (lt (inc $i) (len $path)) }} != nil && {{ end }}
	{{- end }}
{{- end}}

{{- define "inputNilChecks" }}
	{{- $path := . }}

	{{- range $i, $_ := $path -}}
		` + inputVariable + `.{{- joinCamelCase (slice $path 0 inc $i) }}
		{{- if (lt (inc $i) (len $path)) }} != nil && {{ end }}
	{{- end }}
{{- end}}

	{{- if .GetValue }}
		{{- printValue .GetValue }}

	{{- else if .GetProp }}
		{{- template "stateNilChecks" .GetProp.Path }}

	{{- else if .GetInput }}
		{{- template "inputNilChecks" .GetInput.Path }}

	{{- else }}
		{{- errUndefinedOperand }}

	{{- end -}}
`

// TODO: instead of conditionally applying the update, fail if the nil checks don't pass.
// expects an effectParams.
const effectTemplate = `
{{ define "update" }}
	{{- /* Build the left-hand expression, to update the state. But first, initialize the state as needed. */}}

	{{- $dst := .Update.GetDest }}
	{{- if not $dst }}{{ errNoPropertySpecified }}{{ end }}

	{{- $lh := printf "` + stateVariable + `.%s" (joinCamelCase $dst.Path) }}

	{{- /* Initialize state properties, as needed  */}}

	{{- template "initializeStateProperty" (newInitializeStatePropertyExpressionParams $dst.Path "` + stateVariable + `" .State) }}

	{{- /* Build the right-hand side expression. */}}

	{{- $src := .Update.GetSrc }}
	{{- if not $src }}{{ errNoSourceSpecified }}{{ end }}

	{{- if $src.GetValue }}
		{{- $v := $src.GetValue }}
		{{- $lh }} = {{ printValue $v }}
	{{- else if $src.GetProp }}
		{{- $p := $src.GetProp }}
		{{- $path := $p.Path }}
		{{- $trimmedPath := (len $p.Path | dec | slice $p.Path 0) }}

		{{- if $trimmedPath }}
		if {{ end }}

		{{- range $i := slice $path 0 (dec (len $path)) }}
			{{- if $i }} && {{ end -}}
			(` + stateVariable + `.{{ inc $path 1 | slice $p.path 0 | joinCamelCase }} != nil)
		{{- end }}

		{{- if $trimmedPath }}{{ "{" }}
		{{- end }}

		{{- $lh }} = ` + inputVariable + `.{{ joinCamelCase $path }}

		{{- if $trimmedPath }}{{ "}" }}
		{{- end }}
	{{- else if $src.GetInput }}
		{{- $p := $src.GetInput }}
		{{- $path := $p.Path }}
		{{- $trimmedPath := (len $p.Path | dec | slice $p.Path 0) }}

		{{- if $trimmedPath }}
		if {{ end }}

		{{- range $i := slice $path 0 (dec (len $path)) }}
			{{- if $i }} && {{ end -}}
			(` + inputVariable + `.{{ inc $path 1 | slice $p.path 0 | joinCamelCase }} != nil)
		{{- end }}

		{{- if $trimmedPath }}{{ "{" }}
		{{- end }}

		{{- $lh }} = ` + inputVariable + `.{{ joinCamelCase $path }}

		{{- if $trimmedPath }}{{ "}" }}
		{{- end }}
	{{- else }}
		{{- errNoSourcePropertyOrValue }}
	{{- end }}
{{- end }}

{{- if .Effect.GetUpdate }}
	{{- template "update" (newUpdateEffectParams .State .Effect.GetUpdate) }}
{{- else }}
	{{- errNoEffectSpecified }}
{{- end }}
`

var responseAppendExpressionTemplate = `
	{{- $prefix := "` + responseVariable + `.` + responseStateFieldNameCamelCase + `" }}

	{{- template "initializeStateProperty" newInitializeStatePropertyExpressionParams .Path $prefix .State }}
	{{- $prefix }}.{{ joinCamelCase .Path }} = ` + stateVariable + `.{{ joinCamelCase .Path }}
`

const initializeStatePropertyExpression = `
	{{- $path := .Path}}
	{{- $identifier := .Identifier}}
	{{- $msgType := .State}}

	{{- range $i, $_ := slice $path 0 (dec (len $path))}}

		{{- $field := $msgType.FindFieldByName (index $path $i)}}
		{{- if not $field}}{{errNoField $path $i}}{{end}}

		{{- $msgType = $field.GetMessageType}}
		{{- if not $msgType}}{{errNoMessageType $path $i}}{{end}}

		{{- $typeName := goTypeOfField $field}}
		{{- if eq (index $typeName 0) '*'}}
			{{- $typeName = slice $typeName 1}}

			{{- $parts := split $typeName "."}}
			{{- $n := len $parts}}
			{{- if or (eq $n 0) (gt $n 2)}}{{errBadTypeName $typeName}}
			{{- else if eq $n 2}}{{$typeName = index $parts 1}}{{end}}

			{{- $fullResponseFieldName := printf "%s.%s" $identifier (joinCamelCase (slice $path 0 (inc $i)))}}
			if {{$fullResponseFieldName}} == nil {
				{{$fullResponseFieldName}} = &{{$typeName}}{}
			}
		{{- end}}

	{{- end }}
`
