package main

import (
	"fmt"
	"text/template"

	pb "github.com/angelbeltran/game-engine/protoc-gen-game/game_engine_pb"
)

//
// Template binding and construction
//

var definitions = definition{
	Name: "service",
	Funcs: template.FuncMap{
		"printEffect":                   printEffect,
		"printResponseAppendExpression": printResponseAppendExpression,
	},
	Template: serviceTemplate,
	Definitions: []definition{{
		Name: "rule",
		Funcs: template.FuncMap{
			"unexpectedOperator": func(op interface{}) (interface{}, error) {
				return nil, fmt.Errorf("unexpected operator: %s", op)
			},
			"errNoRuleDefined": func() (interface{}, error) {
				return nil, fmt.Errorf("rule empty or missing")
			},
		},
		Template: ruleTemplate,
		Definitions: []definition{{
			Name: "operandWithNilCheck",
			Funcs: template.FuncMap{
				"inc": func(i int) int {
					return i + 1
				},
				"printValue": func(msg *pb.Value) (interface{}, error) {
					_, v, err := extractValue(msg)
					return v, err
				},
				"joinCamelCase": joinCamelCase,
				"errUndefinedOperand": func() (interface{}, error) {
					return nil, fmt.Errorf("undefined operand")
				},
			},
			Template: operandWithNilCheckTemplate,
		}},
	}},
}

type definition struct {
	Name        string
	Funcs       template.FuncMap
	Template    string
	Definitions []definition
}

func parseDefinition(parent *template.Template, def definition) (map[string]*template.Template, error) {
	var tmpl *template.Template
	if parent == nil {
		tmpl = template.New(def.Name)
	} else {
		tmpl = parent.New(def.Name)
	}

	tmpl, err := tmpl.Funcs(def.Funcs).Parse(def.Template)
	if err != nil {
		return nil, fmt.Errorf("failed to parse %s template: %w", def.Name, err)
	}

	res := map[string]*template.Template{
		def.Name: tmpl,
	}

	for _, sub := range def.Definitions {
		m, err := parseDefinition(tmpl, sub)
		if err != nil {
			return nil, err
		}

		for k, v := range m {
			res[k] = v
		}
	}

	return res, nil
}

//
// Templates
//

// expects a generationOptions
const serviceTemplate = `
// Generated by protoc-gen-game. DO NOT EDIT.
package {{.Package}}

import (
{{range $_, $import := .Imports}}	{{printf "%q" $import}}
{{end}}
)

func NewServer(port uint) (*grpc.Server, net.Listener, error) {
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
	if err != nil {
		return nil, nil, err
	}

	srv := grpc.NewServer()
	Register{{.Service.GetName}}Server(srv, new(gameEngine))

	return srv, lis, nil
}

type gameEngine struct {
	Unimplemented{{.Service.GetName}}Server
}

{{$responseStateFieldName := .ResponseStateFieldName}}
{{$responseErrorFieldName := .ResponseErrorFieldName}}
{{$state := .State}}
{{$responseType := .Response.GetName}}
{{range $_, $bundle := .Methods}}
func (e *gameEngine) {{$bundle.Method.GetName}}(ctx context.Context, in *{{$bundle.Method.GetInputType.GetName}}) (*{{$responseType}}, error) {
	{{- with $action := $bundle.Action -}}
		state.Lock()
		defer state.Unlock()

		// Enforce the rules
		allowed := {{template "rule" $action.Rule}}
		if !allowed {
			return &{{$responseType}}{
				{{$responseErrorFieldName}}: &game_engine_pb.Error{
					Code: {{printf "%q" $action.Error.Code}},
					Msg: {{printf "%q" $action.Error.Msg}},
				},
			}, nil
		}

		// Apply any effects
		{{range $_, $effect := $action.Effect}}
		{{printEffect "state" "in" $state $effect}}
		{{end}}

		// Construct the response
		res := {{$responseType}}{
			{{$responseStateFieldName}}: new({{$state.GetName}}),
		}

		{{range $_, $response := $action.Response}}
		{{printResponseAppendExpression (print "res." $responseStateFieldName) "state" $state $response.Path}}
		{{end}}

		return &res, nil

	{{- else -}}

		return &{{$responseType}}{
			{{$responseErrorFieldName}}: &game_engine_pb.Error{
				Msg: "unimplemented",
			},
		}, nil

	{{- end -}}
}
{{end}}

var state struct{
	{{.State.GetName}}
	sync.Mutex
}
`

// expects a *pb.Rule
const ruleTemplate = `
{{- define "operator"}}
	{{- $op := .Operator}}

	{{- if (eq $op 1) -}}		==
	{{- else if (eq $op 2)}}	!=
	{{- else if (eq $op 3)}}	<
	{{- else if (eq $op 4)}}	<=
	{{- else if (eq $op 5)}}	>
	{{- else if (eq $op 6)}}	>=
	{{- else}}{{unexpectedOperator $op}}
	{{- end -}}
{{end}}

{{- define "single"}}
	{{- template "operandWithNilCheck" .Left }} {{template "operator" .}} {{- template "operandWithNilCheck" .Right -}}
{{end}}

{{- define "general"}}
	{{- if .GetSingle}}
		{{- template "single" .GetSingle}}

	{{- else if .GetAnd}}
		{{- range $i, $rule := .GetAnd.Rules}}
			{{- if $i }} && {{end -}}
			({{ template "general" $rule }})
		{{- end}}

	{{- else if .GetOr}}
		{{- range $i, $rule := .GetOr.Rules}}
			{{- if $i }} || {{end -}}
			({{ template "general" $rule }})
		{{- end}}
	{{- else}}{{errNoRuleDefined}}
	{{- end}}
{{- end}}

{{- template "general" . }}
`

// expected *pb.Operand
const operandWithNilCheckTemplate = `
{{- define "stateNilChecks" }}
	{{- $path := . }}

	{{- range $i, $_ := $path -}}
		` + stateVariable + `.{{- joinCamelCase (slice $path 0 (inc $i)) }}
		{{- if (lt (inc $i) (len $path)) }} != nil && {{ end }}
	{{- end }}
{{- end}}

{{- define "inputNilChecks" }}
	{{- $path := . }}

	{{- range $i, $_ := $path -}}
		` + inputVariable + `.{{- joinCamelCase (slice $path 0 inc $i) }}
		{{- if (lt (inc $i) (len $path)) }} != nil && {{ end }}
	{{- end }}
{{- end}}

	{{- if .GetValue }}
		{{- printValue .GetValue }}

	{{- else if .GetProp }}
		{{- template "stateNilChecks" .GetProp.Path }}

	{{- else if .GetInput }}
		{{- template "inputNilChecks" .GetInput.Path }}

	{{- else }}
		{{- errUndefinedOperand }}

	{{- end -}}
`
